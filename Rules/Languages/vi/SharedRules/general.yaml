---

# number-sets are a little messy in that the base was converted to a number-set, so we have to match that (simple) case last
- name: pos-neg-number-sets
  tag: number-sets
  match: "*[2][.='+' or .='-']"
  replace:
  #      if: "$Verbosity!='Terse'"
  #      then:
  #      - T: "the" 
  - bookmark: "*[2]/@id"
    #   - test:
  - test:
    - if: "*[2][.='+']"
      then: [T: "d∆∞∆°ng"]
      else: [T: "√¢m"]
  - bookmark: "*[1]/@id"
  - test:
    - if: "*[1][.='‚ÑÇ']"
      then: [T: s·ªë ph·ª©c]
    - else_if: "*[1][.='‚Ñï']"
      then: [T: s·ªë t·ª± nhi√™n]
    - else_if: "*[1][.='‚Ñö']"
      then: [T: s·ªë h·ªØu t·ª∑]
    - else_if: "*[1][.='‚Ñù']"
      then: [T: s·ªë th·ª±c]
    - else_if: "*[1][.='‚Ñ§']"
      then: [T: s·ªë nguy√™n]
      else: [x: "*[1][text()]"] # shouldn't happen

- name: dimension-number-sets

  # should be single digit integer at this point (e.g, R^3)
  tag: number-sets
  match: "count(*)=2"
  replace:
  - bookmark: "*[1]/@id"
  - test:
    - if: "*[1][.='‚ÑÇ']"
      then: [T: "C"]
    - else_if: "*[1][.='‚Ñï']"
      then: [T: "N"]
    - else_if: "*[1][.='‚Ñö']"
      then: [T: "Q"]
    - else_if: "*[1][.='‚Ñù']"
      then: [T: "R"]
    - else_if: "*[1][.='‚Ñ§']"
      then: [T: "Z"]
      else: [x: "*[1][text()]"] # shouldn't happen
  - bookmark: "*[2]/@id"
  - x: "*[2]"

- name: simple-number-sets
  tag: number-sets
  match: "count(*)=0"
  replace:
  - bookmark: "@id"
  - test:
    - if: ".='‚ÑÇ'"
      then: [T: s·ªë ph·ª©c]
    - else_if: ".='‚Ñï'"
      then: [T: s·ªë t·ª± nhi√™n]
    - else_if: ".='‚Ñö'"
      then: [T: s·ªë h·ªØu t·ª∑]
    - else_if: ".='‚Ñù'"
      then: [T: s·ªë th·ª±c]
    - else_if: ".='‚Ñ§'"
      then: [T: s·ªë nguy√™n]
      else: [x: text()] # shouldn't happen

- name: real-part
  tag: real-part
  match: "."
  replace:
  - bookmark: "@id"
  - T: ph·∫ßn th·ª±c

- name: imaginary-part
  tag: imaginary-part
  match: "."
  replace:
  - bookmark: "@id"
  - T: ph·∫ßn gi·∫£ l·∫≠p

# rules on scripted vertical bars ('evaluated at')
- name: evaluated-at-2
  tag: evaluate
  match: "count(*)=2"
  replace:
  - x: "*[1]"
  - pause: auto
  - T: ƒë∆∞·ª£c t√≠nh t·∫°i
  - pause: auto
  - x: "*[2]"

- name: evaluated-at-3
  tag: evaluate
  match: "count(*)=3"
  replace:
  - x: "*[1]"
  - pause: auto
  - T: ƒë∆∞·ª£c t√≠nh t·∫°i
  - pause: auto
  - x: "*[3]"
  - T: "tr·ª´ c√πng bi·ªÉu th·ª©c ƒë∆∞·ª£c t√≠nh t·∫°i"
  - x: "*[2]"

- name: permutation
  tag: pochhammer
  match: "count(*)=2 and contains(@data-intent-property, ':infix:')"
  replace:
  - x: "*[2]"
  - T: ho√°n v·ªã c·ªßa
  - x: "*[1]"

- name: intervals
  tag: [open-interval, open-closed-interval, closed-interval, closed-open-interval]
  match: "."
  replace:
  #      if: "$Verbosity!='Terse'"
  #      then:
  #      - T: "the" 
  - test:
    - if: "name(.)='open-interval'"
      then: [T: "m·ªü"]
    - else_if: "name(.)='open-closed-interval'"
      then: [T: "ƒë√≥ng m·ªü"]
    - else_if: "name(.)='closed-interval'"
      then: [T: "ƒë∆∞·ª£c ƒë√≥ng"]
      else: [T: "m·ªü ƒë√≥ng"]  # closed-open-interval
  - test:
      if: "$Verbosity!='Terse'"
      then:
      - T: "t·ª´"
      - x: "*[2]"
      - T: "ƒë·∫øn"
      - x: "*[3]"
      else:
      - x: "*[2]"
      - T: "ph·∫©y"
      - x: "*[3]"

- name: default-point
  tag: point
  match: "."
  replace:
  #- test:
  #    if: "$Verbosity!='Terse'"
  #    then:
  #    - T: "the"
  - T: "ƒëi·ªÉm"
  - x: "*[1]"
  - T: "ph·∫©y"
  - x: "*[2]"

- name: bigop-both
  tag: large-op
  match: "count(*) = 3"
  replace:
  # - test:
  #     if: "$Verbosity!='Terse'"
  #     then: [T: the]
  - x: "*[1]"
    #   - test: 
  - T: t·ª´
  - x: "*[2]"
  - T: ƒë·∫øn
  - x: "*[3]"
  - test:
      if: "following-sibling::*"
      then: [T: c·ªßa]

- name: bigop-under
  tag: large-op
  match: "."
  replace:
  # - test:
  #     if: "$Verbosity!='Terse'"
  #     then: [T: the]
  - x: "*[1]"
  - T: tr√™n
  - x: "*[2]"
  - test:
      if: "following-sibling::*"
      then: [T: c·ªßa]

- name: largeop
  tag: mrow
  match: "count(*)=2 and IsInDefinition(*[1], 'LargeOperators')"
  replace:
  # - test:
  #     if: "$Verbosity!='Terse'"
  #     then: [T: the]
  - x: "*[1]"
  - T: c·ªßa
  - x: "*[2]"

- name: msubsup-skip-super
  # handles single, double, etc., prime
  tag: [skip-super, say-super]
  match: "count(*)=3"
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: "ch·ªâ s·ªë d∆∞·ªõi"]
      else: [T: "ch·ªâ s·ªë d∆∞·ªõi"]
  - x: "*[2]"
  - test:
      if: "not(IsNode(*[2],'leaf'))"
      then:
      - test:
          if: "$Verbosity='Terse'"
          then: [T: "h·∫øt ch·ªâ s·ªë d∆∞·ªõi"]        # (en: "end sub")
          else: [T: "h·∫øt ch·ªâ s·ªë d∆∞·ªõi"]              # (en: "end subscript")
      - pause: short
      else_test:
          if: "*[2][self::m:mi]"   # need a pause in "x sub k prime" so the prime is not associated with the 'k'
          then: [pause: short]
  - test:
      if: "name(.)='say-super'"
      then_test:
        if: "$Verbosity='Terse'"
        then: [T: "ch·ªâ s·ªë tr√™n"]
        else: [T: "ch·ªâ s·ªë tr√™n"]
  - x: "*[3]"
  - pause: short


# the order of matching is
# 1. does it match the base of an SI unit
# 2. does it match an English unit (if in an English language)
# 3. does it match an SI prefix followed by an SI that accepts SI prefixes
# Due to this order, some things like "ft" and "cd" mean "feet" vs "femto-tonnes" and "pints" vs "pico-tonnes"
- name: unit
  tag: unit
  match: "."
  variables:
    # If the coefficient is singular, we don't add the plural ending. Finding the coefficient is tricky
    # Normal case (A) "3m" (parents is mrow), but could also be (B) "3 m^2" (etc.) (parent is power/mrow)
    # But it might be in a fraction as (C) "3 m/s" (parent is fraction/mrow) or (D) "3 m^2/s^2" (parent is power/fraction/mrow)
    #   or even (E) {3 m^2}/s (parent is power/mrow)
    # If in a fraction, only look in the numerator to find the coefficient
    # Note: we have a special case for pseudo-scripts like "¬∞" (degrees) which are not powers -- they are essentially "1^¬∞"
    # The following "IfThenElse" logic returns the mrow that potentially contains the coefficient, if it exists
    # The tests are in the order A, B & E, C, D
  - MRowForCoefficient: "IfThenElse(parent::m:mrow, parent::m:mrow,
                         IfThenElse(parent::m:power, ancestor::*[2][self::m:mrow],
                         IfThenElse(parent::m:fraction and not(preceding-sibling::*), ancestor::*[2][self::m:mrow],
                         IfThenElse(parent::m:power[parent::m:fraction and not(preceding-sibling::*)], ancestor::*[3][self::m:mrow], false()) ) ) )"
  - IsSingular: "(not($MRowForCoefficient) and parent::*[name(.)!='skip-super' or *[1][.=1]]) or
                 ($MRowForCoefficient and $MRowForCoefficient[(count(*) = 3 and *[1][self::m:mn and .=1] and *[2]='\u2062')])"

  - Prefix: "''"
  - Word: "''"  
  replace:
  - bookmark: "@id"
  - test:
    # is the whole string match a SI Unit without a prefix?
    - if: "DefinitionValue(., 'Speech', 'SIUnits') != ''"
      then:
      - set_variables: [Word: "DefinitionValue(., 'Speech', 'SIUnits')"]
    - else_if: "DefinitionValue(., 'Speech', 'UnitsWithoutPrefixes') != ''"
      then:
      - set_variables: [Word: "DefinitionValue(., 'Speech', 'UnitsWithoutPrefixes')"]
    - else_if: "DefinitionValue(., 'Speech', 'EnglishUnits') != ''"
      then:
      - set_variables: [Word: "DefinitionValue(., 'Speech', 'EnglishUnits')"]

    # do the first two chars match "da" and the remainder match an SIUnit
    - else_if: "string-length(.) >= 3 and 
                substring(., 1, 2) = 'da' and
                DefinitionValue(substring(., 3), 'Speech', 'SIUnits') != ''"
      then:
      - set_variables:
        - Prefix: "DefinitionValue('da', 'Speech', 'SIPrefixes')"
        - Word: "DefinitionValue(substring(., 3), 'Speech', 'SIUnits')"

    # does the first char match a prefix and the remainder match an SIUnit
    - else_if: "string-length(.) >= 2 and 
                DefinitionValue(substring(., 1, 1), 'Speech', 'SIPrefixes') != ''  and
                DefinitionValue(substring(., 2), 'Speech', 'SIUnits') != ''"
      then:
      - set_variables:
        - Prefix: "DefinitionValue(substring(., 1, 1), 'Speech', 'SIPrefixes')"
        - Word: "DefinitionValue(substring(., 2), 'Speech', 'SIUnits')"

    # not a known unit -- just speak the text, possibly as a plural
    - else:
      - set_variables:
        - Word: "text()"

  # somewhat complicated logic to avoid spaces around "-" as in "centi-grams" vs "centi - grams" -- probably doesn't matter
  - test:
      if: "$Prefix = ''"
      then:
      - test:
        - if: "$IsSingular"
          # HACK: '\uF8FE' is used internally for the concatenation char by 'ct' -- this gets the prefix concatinated to the base
          then: [x: "$Word"]
        - else_if: "DefinitionValue($Word, 'Speech', 'PluralForms') != ''"
          then: [x: "DefinitionValue($Word, 'Speech', 'PluralForms')"]
          else: [x: "$Word"]
      else:
      - x: "$Prefix"
      - ct: "-"
      - test:
        - if: "$IsSingular"
          # HACK: '\uF8FE' is used internally for the concatenation char by 'ct' -- this gets the prefix concatinated to the base
          then: [x: "concat('\uF8FE', $Word)"]
        - else_if: "DefinitionValue($Word, 'Speech', 'PluralForms') != ''"
          then: [x: "concat('\uF8FE', DefinitionValue($Word, 'Speech', 'PluralForms'))"]
          else: [x: "concat('\uF8FE', $Word)"]


- name: sin
  tag: mi
  match: ".='sin'"
  replace:
  - bookmark: "@id"
  - T: "sin"
- name: cos
  tag: mi
  match: ".='cos'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: c√¥ sin]
      else: [T: c√¥ sin]
- name: tan
  tag: mi
  match: ".='tan' or .='tg'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: tang]
      else: [T: tang]
- name: sec
  tag: mi
  match: ".='sec'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: sin ƒë·∫£o]
      else: [T: sin ƒë·∫£o]
- name: csc
  tag: mi
  match: ".='csc'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: c√¥ sin ƒë·∫£o]
      else: [T: c√¥ sin ƒë·∫£o]
- name: cot
  tag: mi
  match: ".='cot'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: c√¥ tang]
      else: [T: c√¥ tang]

- name: sinh
  tag: mi
  match: ".='sinh'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: sin h√≠p b∆° b√¥n]
      else: [T: sin h√≠p b∆° b√¥n]
- name: cosh
  tag: mi
  match: ".='cosh'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: c√¥ sin h√≠p b∆° b√¥n]
      else: [T: c√¥ sin h√≠p b∆° b√¥n]
- name: tanh
  tag: mi
  match: ".='tanh'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: tang h√≠p b∆° b√¥n]
      else: [T: tang h√≠p b∆° b√¥n]
- name: sech
  tag: mi
  match: ".='sech'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: x√™ can h√≠p b∆° b√¥n]
      else: [T: x√™ can h√≠p b∆° b√¥n]
- name: csch
  tag: mi
  match: ".='csch'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: c√¥ x√™ can h√≠p b∆° b√¥n]
      else: [T: c√¥ x√™ can h√≠p b∆° b√¥n]
- name: coth
  tag: mi
  match: ".='coth'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: c√¥ tang h√≠p b∆° b√¥n]
      else: [T: c√¥ tang h√≠p b∆° b√¥n]
- name: arcsin
  tag: mi
  match: ".='arcsin'"
  replace:
  - bookmark: "@id"
  - T: "·∫°t sin"
- name: arccos
  tag: mi
  match: ".='arccos'"
  replace:
  - bookmark: "@id"
  - T: "·∫°t c√¥ sin"
- name: arctan
  tag: mi
  match: ".='arctan'"
  replace:
  - bookmark: "@id"
  - T: "·∫°t tang"
- name: arccot
  tag: mi
  match: ".='arccot'"
  replace:
  - bookmark: "@id"
  - T: "·∫°t c√¥ tang"

-
  name: log    # handle both log and ln (if in an mrow, 'intents' are used)
  tag: mi
  match: ".= 'log' or .= 'ln'"
  replace:
  - bookmark: "@id"
  - test:
    - if: "$Verbosity!='Terse'"
      then: [T: ""]      # phrase('the' logarithm function is used in mathematics)
  - test:
    - if: ".= 'log'"
      then: [T: "l√≥c"]      # phrase(the 'log' function is used in mathematics)
    - else_if: "$Verbosity='Terse'"
      then: [T: "l√≥c n∆° be"]
      else: [T: "l√≥c n∆° be"]      # phrase(the 'natural log' function is used in mathematics)

- #   that eliminates the need for the if: else_if: ...
  name: multi-line
  # IDEA:  set a variable with the word to say for the row (e.g., RowLabel = Row/Case/Line/...)
  tag: [piecewise, system-of-equations, lines]
  match: "."
  variables: [IsColumnSilent: true()]
  replace:
  - x: "count(*)"
  - test:
    - if: "self::m:piecewise"
      then: [T: "tr∆∞·ªùng h·ª£p"]
    - else_if: "self::m:system-of-equations"
      then: [T: "bi·ªÉu th·ª©c"]
      else: [T: "d√≤ng"]
    #- test:
    #- if: "count(*) > 1"
    #then: [ct: "s"]    # plural
  - pause: short
  - x: "*"

- name: default-multiline
  tag: [mtr, mlabeledtr]
  match: "parent::m:piecewise or parent::m:system-of-equations or parent::m:lines"
  replace:
  - pause: medium
  - test:
    - if: "parent::m:piecewise"
      then: [T: "tr∆∞·ªùng h·ª£p"]
    - else_if: "parent::m:system-of-equations"
      then: [T: "bi·ªÉu th·ª©c"]
      else: [T: "d√≤ng"]
  - x: "count(preceding-sibling::*)+1"
  - test:
      if: .[self::m:mlabeledtr]
      then:
      - T: v·ªõi
      - x: "*[1]/*"
  - pause: medium
  - test:
      if: .[self::m:mlabeledtr]
      then: [x: "*[position()>1]"]
      else: [x: "*"]

- name: default-multiline
  tag: mtd
  match: "parent::*[parent::m:piecewise or parent::m:system-of-equations or parent::m:lines]"
  replace:
  - x: "*"
  - test:
    # short pause after each element; medium pause if last element in a row; long pause for last element in matrix
    - if: count(following-sibling::*) > 0
      then: [pause: short]
    - else_if: count(../following-sibling::*) > 0
      then: [pause: medium]
      else: [pause: long]

# Matrix/Determinant rules
# matrix and determinant are the same other than "matrix"/"determinant" based on the bracketing chars
# the pausing logic is pushed down to the <mtd>
# the rules either speak the <mtr>s (to get "row n") or the <mtd>s. "column n" spoken if $IsColumnSilent is false
- name: 1x1-matrix

  tag: [matrix, determinant]
  variables: [IsColumnSilent: true()]
  match: "count(*)=1 and *[self::m:mtr][count(*) = 1]"
  replace:
  - test:
      if: "self::m:determinant" # just need to check the first bracket since we know it must be (, [, or |
      then: [T: ƒë·ªãnh th·ª©c]
      else: [T: ma tr·∫≠n]
    #   - OT: the
  - T: "1 1"
  - T: c√≥ ƒë·∫ßu v√†o l√†
  - x: "*[1]/*"

# simpler reading methods for smaller matrices if the entries are simple
- name: 2-or-3x1-matrix
  tag: matrix
  variables: [IsColumnSilent: true()]
  match:
  - "$ClearSpeak_Matrix != 'SpeakColNum' and " # "simple" isn't used for this preference
  - "*[self::m:mtr][count(*) = 1] and " # one column
  - count(*)<=3 and # at least two rows
  - IsNode(*/*/*,'simple') # IsNode() returns true if all the nodes are simple
  replace:
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [T: v√©c t∆°]
      else: [T: ma tr·∫≠n]
    #   - T: the
  - x: count(*)
  - T: 1 c·ªôt
  - pause: long
  - x: "*/*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - T: "k·∫øt th√∫c"
      - test:
          if: $ClearSpeak_Matrix = 'EndVector'
          then: [T: v√©c t∆°]
          else: [T: ma tr·∫≠n]

- name: default-column-matrix
  tag: matrix
  variables: [IsColumnSilent: true()]
  match: "*[self::m:mtr][count(*) = 1]"
  replace:
  #- T: the
  - x: "count(*)"
  - T: nh√¢n 1 c·ªôt
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [T: v√©c t∆°]
      else: [T: ma tr·∫≠n]
  - pause: long
  - x: "*" # select the rows (mtr)
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then: [T: "h·∫øt ma tr·∫≠n"]

- name: 1x2-or-3-matrix
  tag: matrix
  variables: [IsColumnSilent: "$SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix != 'SpeakColNum'"]
  match:
  - "$ClearSpeak_Matrix != 'SpeakColNum' and " # "simple" isn't used for this preference
  - count(*)=1  and # one row
  - count(*[1]/*)<=3 and # at least two cols
  - IsNode(*/*/*,'simple') # IsNode() returns true if all the nodes are simple
  replace:
  - T: 1 nh√¢n
  - x: count(*/*)
  - T: "d√≤ng"
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [T: v√©c t∆°]
      else: [T: ma tr·∫≠n]
  - pause: long
  - x: "*/*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - T: "h·∫øt"
      - test:
          if: $ClearSpeak_Matrix = 'EndMatrix'
          then: [T: ma tr·∫≠n]
          else: [T: v√©c t∆°]

- name: default-row-matrix
  tag: matrix
  variables: [IsColumnSilent: "$SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix = 'SilentColNum'"]
  match: "count(*)=1" # one row
  replace:
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [T: v√©c t∆°]
      else: [T: ma tr·∫≠n]
  - T: m·ªôt nh√¢n
  - x: "count(*/*)"
  - T: "d√≤ng"
  - pause: long
  - pause: medium
  - x: "*/*" # select the cols (mtd)
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - T: "h·∫øt"
      - test:
          if: $ClearSpeak_Matrix = 'EndMatrix'
          then: [T: ma tr·∫≠n]
          else: [T: v√©c t∆°]

- name: simple-small-matrix
  tag: [matrix, determinant]
  match:
  - "$ClearSpeak_Matrix != 'SpeakColNum' and " # "simple" isn't used for this preference
  - (count(*)<=3 and count(*[1]/*)<=3) and # no bigger than a 3x3 matrix
  - IsNode(*/*/*,'simple') # IsNode() returns true if all the nodes are simple
  variables: [IsColumnSilent: "$SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix != 'SpeakColNum'"]
  replace:
  #- T: the
  - test:
      if: "self::m:determinant"
      then: [T: ƒë·ªãnh th·ª©c]
      else: [T: ma tr·∫≠n]
  - x: count(*)
  - T: nh√¢n
  - x: count(*[self::m:mtr][1]/*)
  - pause: long
  - x: "*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - T: h·∫øt
      - test:
          if: "self::m:determinant"
          then: [T: ƒë·ªãnh th·ª©c]
          else: [T: ma tr·∫≠n]

- name: default-matrix
  tag: [matrix, determinant]
  variables: [IsColumnSilent: "$SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix = 'SilentColNum'"]
  match: "."
  replace:
  #- T: the
  - test:
      if: "self::m:determinant"
      then: [T: ƒë·ªãnh th·ª©c]
      else: [T: ma tr·∫≠n]
  - x: "count(*)"
  - T: nh√¢n
  - x: "count(*[self::m:mtr][1]/*)"
  - pause: long
  - x: "*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - T: h·∫øt
      - test:
          if: "self::m:determinant"
          then: [T: ƒë·ªãnh th·ª©c]
          else: [T: ma tr·∫≠n]

- name: chemistry-msub

  tag: [chemical-formula]
  match: "*[1][.='msub']"
  replace:
  - x: "*[2]"
  - x: "*[3]"
  - test:
      if: "$Verbosity='Verbose'"
      then: [T: "d∆∞·ªõi"]
      else_test:
        if: "$Verbosity='Medium'"
        then: [T: ""]
  #- x: "*[3]"

- name: chemistry-msup
  tag: [chemical-formula]
  match: "*[1][.='msup']"
  replace:
  - x: "*[2]"
  - x: "*[3]"
  - test:
      if: "$Verbosity='Verbose'"
      then: [T: "tr√™n"]
      else_test:
        if: "$Verbosity='Medium'"
        then: [T: ""]
  #- x: "*[3]"
  - test:
      if: "following-sibling::*[1][.='+' or .='-']" # a little lazy -- assumes chemistry superscripts end with + or -
      then: [pause: medium]

- # Instead, we just deal with up to two prescripts and up to four postscripts (repeating blocks of similar code [UGLY!])
  # This hopefully covers all reasonable cases...
  name: chemistry-scripts
  # There currently is no way to do sub/super for n-ary number of args
  tag: [chemical-formula, chemical-nuclide]
  variables:
  # computing the number of postscripts is messy because of <mprescripts> being optionally present -- we use "mod" to get the count right
  - Prescripts: "m:mprescripts/following-sibling::*"
  - NumChildren: "count(*)" # need to stash this since the count is wrong inside '*[...]' below
  - Postscripts: "*[position()>1 and position() < (last() + ($NumChildren mod 2) -count($Prescripts))]"
  match: . # should only be msubsup or mmultiscripts at this point
  replace:
  - test:
      if: "$Prescripts" # we have at least one pre sub/super 
      then:
      # nuclide: speak the superscript first
      - test:
          if: "not($Prescripts[2][self::m:none])"
          then:
          - x: "$Prescripts[2]"
          - test:
              if: "$Verbosity='Verbose'"
              then: [T: "tr√™n"]
              else_test:
                if: "$Verbosity='Medium'"
                then: [T: ""]
          #- x: "$Prescripts[2]"
          - pause: "short"
      - test:
          if: "not($Prescripts[1][self::m:none])"
          then:
          - x: "$Prescripts[1]"
          - test:
              if: "$Verbosity='Verbose'"
              then: [T: "d∆∞·ªõi"]
              else_test:
                if: "$Verbosity='Medium'"
                then: [T: ""]
          #- x: "$Prescripts[1]"
          - pause: "short"
      - test:
          if: "count($Prescripts) > 2" # can this happen for chemistry??? we allow for one *extra* pre sub/super pair
          then:
          - test:
              if: "not($Prescripts[4][self::m:none])"
              then:
              - x: "$Prescripts[4]"
              - test:
                  if: "$Verbosity='Verbose'"
                  then: [T: "tr√™n"]
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [T: ""]
              #- x: "$Prescripts[4]"
              - pause: "short"
          - test:
              if: "not($Prescripts[3][self::m:none])"
              then:
              - x: "$Prescripts[3]"
              - test:
                  if: "$Verbosity='Verbose'"
                  then: [T: "d∆∞·ªõi"]
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [T: ""]
              #- x: "$Prescripts[3]"
              - pause: "short"
  - x: "*[1]" # base
  - test:
      if: "$Postscripts"
      then:
      - test:
          if: "not($Postscripts[1][self::m:none])"
          then:
          - x: "$Postscripts[1]"
          - test:
              if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
              then: [T: "d∆∞·ªõi"]
              else_test:
                if: "$Verbosity='Medium'"
                then: [T: ""]
          #- x: "$Postscripts[1]"
          - pause: "short"
      - test:
          if: "not($Postscripts[2][self::m:none])"
          then:
          - x: "$Postscripts[2]"
          - test:
              if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
              then: [T: "tr√™n"]
              else_test:
                if: "$Verbosity='Medium'"
                then: [T: ""]
          #- x: "$Postscripts[2]"
          - pause: "short"
      - test:
          if: "count($Postscripts) > 2"
          then:
          - test:
              if: "not($Postscripts[3][self::m:none])"
              then:
              - x: "$Postscripts[3]"
              - test:
                  if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
                  then: [T: "d∆∞·ªõi"]
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [T: ""]
              #- x: "$Postscripts[3]"
              - pause: "short"
          - test:
              if: "not($Postscripts[4][self::m:none])"
              then:
              - x: "$Postscripts[4]"
              - test:
                  if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
                  then: [T: "tr√™n"]
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [T: ""]
              #- x: "$Postscripts[4]"
              - pause: "short"
          - test:
              if: "count($Postscripts) > 4"
              then:
              - test:
                  if: "not($Postscripts[5][self::m:none])"
                  then:
                  - x: "$Postscripts[5]"
                  - test:
                      if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
                      then: [T: "d∆∞·ªõi"]
                      else_test:
                        if: "$Verbosity='Medium'"
                        then: [T: ""]
                  #- x: "$Postscripts[5]"
                  - pause: "short"
              - test:
                  if: "not($Postscripts[6][self::m:none])"
                  then:
                  - x: "$Postscripts[6]"
                  - test:
                      if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
                      then: [T: "tr√™n"]
                      else_test:
                        if: "$Verbosity='Medium'"
                        then: [T: ""]
                  #- x: "$Postscripts[6]"
                  - pause: "short"
              - test:
                  if: "count($Postscripts) > 6"
                  then:
                  - test:
                      if: "not($Postscripts[7][self::m:none])"
                      then:
                      - x: "$Postscripts[7]"
                      - test:
                          if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
                          then: [T: "d∆∞·ªõi"]
                          else_test:
                            if: "$Verbosity='Medium'"
                            then: [T: ""]
                      #- x: "$Postscripts[7]"
                      - pause: "short"
                  - test:
                      if: "not($Postscripts[8][self::m:none])"
                      then:
                      - x: "$Postscripts[8]"
                      - test:
                          if: "$Verbosity='Verbose' and not(self::m:chemical-formula)"
                          then: [T: "tr√™n"]
                          else_test:
                            if: "$Verbosity='Medium'"
                            then: [T: ""]
                      #- x: "$Postscripts[8]"
                      - pause: "short"
      - test:
          if: "$Postscripts[last()][not(self::m:none)] and following-sibling::*[1][.='+' or .='-']"
          then: [pause: medium]

- name: chemistry


  tag: chemical-equation
  match: "."
  replace:
  - x: "*"

- name: chemical-element
  tag: chemical-element
  match: "."
  replace:
  - bookmark: "@id"
  - spell: text()
  - pause: short

- name: chemical-state
  tag: chemical-state
  match: "."
  replace:
  - bookmark: "*[1]/@id"
  - test:
    - if: ".='s'"
      then: [T: "th·ªÉ r·∫Øn"]
    - else_if: ".='l'"
      then: [T: "th·ªÉ l·ªèng"]
    - else_if: ".='g'"
      then: [T: "th·ªÉ kh√≠"]
      else: [T: "th·ªÉ l·ªèng"] # (aq)
  - pause: short

- name: chemical-formula-operator-bond
  tag: chemical-formula-operator
  match: "@data-chemical-bond"
  replace:
  # FIX: this might be better/more efficient if in unicode.yaml
  - bookmark: "@id"
  - test:
    - if: ".='-' or .=':'"
      then: [T: "n·ªëi ƒë∆°n"]      # phrase(a 'single bond' is formed when two atoms share one pair of electrons)
    - else_if: ".='=' or .='‚à∑'"
      then: [T: "n·ªëi ƒë√¥i"]      # phrase(a 'double bond' may occur when two atoms share two pairs of electrons)
    - else_if: ".='‚â°'"
      then: [T: "n·ªëi ba"]      # phrase(a 'triple bond' occurs when two atoms share three pairs of electrons)
    - else_if: ".='‚â£'"
      then: [T: "n·ªëi b·ªën"]      # phrase(a 'quadruple bond' occurs when two atoms share four pairs of electrons)
      else: [x: "text()"]

- name: chemical-formula-operator
  tag: chemical-formula-operator
  match: "."
  replace:
    x: "text()"

- name: chemical-arrow-operator
  tag: chemical-arrow-operator
  match: "."
  replace:
  # FIX: this might be better/more efficient if in unicode.yaml
  - bookmark: "@id"
  - test:
    - if: ".='‚Üí' or .='‚ü∂'"
      then_test:
        if: "$Verbosity='Terse'"
        then: [T: "cho ra"]      # phrase(hydrogen and oxygen 'forms' water )
        else: [T: "ph·∫£n ·ª©ng cho ra"]      # phrase(hydrogen and oxygen 'reacts to form' water)
    - else_if: ".='‚áå' or .='ü£ë'" # U+01F8D1
      then: [T: "m≈©i t√™n hai chi·ªÅu"]      # phrase(a reactant 'is in equilibrium with' a product)
    - else_if: ".='ü£ì'" # U+1F8D3
      then: [T: "m≈©i t√™n chi·ªÅu b√™n tr√°i"]      # phrase(the reactant 'is in equilibrium biased to the left with' the product)
    - else_if: ".='ü£í'" # U+1F8D2
      then: [T: "m≈©i t√™n chi·ªÅu b√™n ph·∫£i"]      # phrase(the reactant 'is in equilibrium biased to the right with' the product)
      else: [x: "*"]

- name: chemical-equation-operator
  tag: chemical-equation-operator
  match: "."
  replace:
  - bookmark: "@id"
  - x: "text()"

- name: none
  tag: none
  match: "../../*[self::m:chemical-formula or self::m:chemical-nuclide]"
  replace:
  - T: "" # don't say anything

- name: ignore-intent-wrapper
  tag: intent-wrapper
  match: "."
  replace:
  - x: "*"
