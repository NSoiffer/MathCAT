---
# FIX: how should whitespace be handled?
-
  name: whitespace-omission
  tag: "!*"
  match: "not(self::m:math) and not($MatchingWhitespace) and (@data-previous-space-width >= 0.25 or @data-following-space-width >= 0.25)"
  replace:
   - with:
      variables: [MatchingWhitespace: "true()"]
      replace:
      - test:
        - if: "(@class='MathML-unit' or BaseNode(.)[@class='MathML-unit']) and @data-previous-space-width >= 0.25"  # BANA 5.3(a)
          then: [t: "ùêñ"]
        - else_if: "@data-previous-space-width > 1.1"
          then: [t: "‚†¨"]
        - else_if: "@data-previous-space-width >= 0.25"      # thickspace
          then: [t: "ùêñ"]
      - x: "."
      - test:
        - if: "(@class='MathML-unit' or BaseNode(.)[@class='MathML-unit']) and @data-following-space-width >= 0.25" # BANA 5.3(a)
          then: [t: "ùêñ"]
        - else_if: "@data-following-space-width > 1.1"
          then: [t: "‚†¨"]
        - else_if: "@data-following-space-width >= 0.25"      # thickspace
          then: [t: "ùêñ"]

-
  name: omission-intent
  tag: "!*"
  match: "contains(@intent, ':blank')"
  replace: 
  - t: "‚†¨"

-
  name: unicode-override
  tag: "*"
  match: "@data-unicode"
  replace: 
  - x: "@data-unicode"

-
  name: default
  tag: msqrt
  match: "."
  replace: 
  # example show use of {}s even when not needed, so no testing
  - test:
      if: "$LaTeX_UseShortName"
      then: [t: "\\s{"]
      else: [t: "\\sqrt{"]
  - x: "*[1]"
  - t: "}"


-
  name: default
  tag: mroot
  match: "."
  replace: 
  # example show use of {}s even when not needed, so no testing
  - test:
      if: "$LaTeX_UseShortName"
      then: [t: "\\s["]
      else: [t: "\\sqrt["]
  - x: "*[2]"
  - t: "]{"
  - x: "*[1]"
  - t: "}"

-
  name: default
  tag: mfrac
  match: "."
  replace: 
  # example show use of {}s even when not needed, so no testing
  - test:
      if: "$LaTeX_UseShortName"
      then: [t: "\\f{"]
      else: [t: "\\frac{"]
  - x: "*[1]"
  - t: "}{"
  - x: "*[2]"
  - t: "}"

-
  #GTM 14.3.3 (not sure what else vertical juxtaposition applies to)
  name: binomial-frac
  tag: mrow
  match: "IsBracketed(., '(', ')') and *[2][self::m:mfrac][@linethickness=0]"
  replace: 
  - t: "\\binom{"
  - x: "*[2]/*[1]"
  - t: "}{"
  - x: "*[2]/*[2]"
  - t: "}"


- name: binomial-table
  tag: mrow
  match: "IsBracketed(., '(', ')') and *[2][self::m:mtable][count(*)=2 and count(*[1])=1] and contains(@intent, 'binomial(')"
  replace:
  - t: "\\binom{"
  - x: "*[2]/*[1]/*[1]/*[1]"
  - t: "}{"
  - x: "*[2]/*[2]/*[1]/*[1]"
  - t: "}"

# FIX: implement (use \begin{pmatrix} x; & y; & z-3 \end{pmatrix})
# Matrix/Determinant rules
# matrix and determinant are the same other than "matrix"/"determinant" based on the bracketing chars
# we don't do spatial layout, instead the beginning/ending of each row uses the enlarged bracketing chars
-
  name: default-matrix
  tag: mrow
  variables:
  - MatrixType: "IfThenElse(*[1][.='('], 'pmatrix', 
                 IfThenElse(*[1][.='['], 'bmatrix',
                 IfThenElse(*[1][.='|'], 'vmatrix',
                 IfThenElse(*[1][.='‚Äñ'], 'Vmatrix','Bmatrix')
                )))"
  match:
  - "*[2][self::m:mtable] and"
  - "(IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or"
  - " IsBracketed(., '|', '|') or IsBracketed(., '‚Äñ', '‚Äñ') or IsBracketed(., '{', '}') )"
  replace:
  - t: "\\begin{"
  - x: "string($MatrixType)"     # need to get $MatrixType eval'd so that it is converted to braille (doesn't work if I do it in 'variables') 
  - t: "}ùêñ"
  - x: "*[2]"
  - t: "\\end{"
  - x: "string($MatrixType)"     # need to get $MatrixType eval'd so that it is converted to braille (doesn't work if I do it in 'variables') 
  - t: "}ùêñ"

-
  name: default-mtable
  tag: mtable
  match: "."
  replace: [x: "*"]
-
  name: default
  tag: [mtr, mlabeledtr]
  match: "."
  replace:
  #  - test:
  #     if: .[self::m:mlabeledtr]
  #     then:
  #        - t: "‚†ó‚†ï‚†∫W‚†á‚†Å‚†É‚†ë‚†á‚†∏‚†í"  # "row label:"
  #        - x: "*[1]/*"           # contents of row label
  #  - test:
  #     if: .[self::m:mlabeledtr]
  #     then: [x: "*[position()>1]"]
  #     else: {x: "*"}
  - x: "*"
  - test: 
      if: "following-sibling::*"
      then: [t: "ùêñ\\\\ùêñ"]

-
  name: default
  tag: mtd
  match: "."
  replace:
  - x: "*"
  - test:
      if: "following-sibling::*"
      then: [t: "ùêñ&ùêñ"]

-
  name: no-content
  tag: math
  match: "not(*)"      # empty
  replace: [t: "ùêñ"]    # not sure that is right, but this shouldn't happen

-
  name: default
  tag: math
  match: "."
  variables:
  - MatchingWhitespace: "false()"
  replace: [x: "*"]

-
  name: empty-mrow
  tag: mrow
  match: "not(*)"
  replace: [t: "ùêñ"] # not sure what is correct -- if in a fraction, probably something is better than nothing

-
  name: default
  tag: mrow
  match: "."
  replace: [x: "*"]


-
  # operator omission
  name: operator-omission
  tag: mo
  # normally(?) this is an omission, but the case 6'2" causes problems due to WIRIS
  # in that case, it doesn't put the ft/in in a superscript and thinks the space is an operator
  # canonicalization moves them into <msup> with base <mn>, so this shouldn't be an omission for that case
  match: ".='\u00A0' and @width > 1.1 and 
          not( preceding-sibling::*[1][self::m:msup and *[2][self::m:mo]] and
              following-sibling::*[1][self::m:msup and *[2][self::m:mo]] )"
  replace:
  - t: "‚†¨"   # empty space for omission

# FIX: need to deal with ~ ^ \
#  they have macros \textasciitilde, \textasciicircum, and \textbackslash
#  these probably aren't appropriate for EuroBraille
-
  # it seems that if a matching vertical bar is the start char, then it has a space after it
  name: vertical-bar
  tag: mo
  match: ".='|'"
  replace:
  - x: "text()"
  - test:
      if: "not(preceding-sibling::*)"
      then: [t: "ùêñ"]

-
  name: default
  tag: mo
    # add spaces around comparison operators unless they are in a script position,
  match: "."
  replace:
  - test:
      # if: "DEBUG(parent::m:mrow and DEBUG(not(DEBUG(IsInDefinition(DEBUG(.), 'Braille', 'NoSpacesBefore')))))"
      # then: [t: "ùêñ"]
      if: "parent::m:mrow"
      then_test:
          if: "not(IsInDefinition(., 'Braille', 'NoSpacesBefore'))"
          then: [t: "ùêñ"]
  - x: "text()"
  - test:
      if: "parent::m:mrow and (.=',' or .=';')"     # are there others???
      then: [t: "ùêñ"]


-
  name: default
  tag: mn
  match: "."
  replace:
  - x: "text()" 
    
-
  # FIX: need to deal with all caps
  name: named-functions
  tag: [mi, mtext]
  match: "IsInDefinition(., 'Braille', 'LateXFunctionNames') and not($LaTeX_UseShortName)"
  replace:
  - t: "\\"
  - x: "text()"
  - t: "ùêñ"
    
-
  # FIX: need to deal with all caps
  name: default
  tag: [mi, mtext]
  match: "."
  replace:
  - x: "text()" 

-
  name: default
  tag: mstyle
  match: "."
  replace:
  - test:
      if: "*"
      then: [x: "*"]
      # else do nothing -- no content

-
  # FIX: what should be output
  name: mhchem-hack
  # this captures the output for the mhchem's "<=>", "<<=>", and "<=>>" output (there are no Unicode arrows for them)
  # this isn't a perfect match, but should be good enough and allows merging all three (see github.com/NSoiffer/MathCAT/issues/60)
  tag: mover
  match:
  -    "*[1][substring(., 1, 1)='‚ÜΩ'] and"
  -    "*[2][substring(., string-length(), 1)='‚áÄ']"
  replace:
  - t: "ùêñ"
  - test:
      if: "*[1][self::m:mrow]"
      then_test:
          if: "*[2][self::m:mrow]"
          then: [t: "ü£í"]    # this is currently unassigned and may get used by UTC at some point (<=>)
          else: [t: "ü£î"]    # this is currently unassigned and may get used by UTC at some point (<<=>)
      else: [t: "ü£ì"]        # this is currently unassigned and may get used by UTC at some point (<==>>)
  - t: "ùêñ"

-
  name: "hat"
  tag: "mover"
  match: "*[2][.='^']"
  replace:
  - t: "\\hat{"
  - x: "*[1]"
  - t: "}"

-
  name: "bar"
  tag: "mover"
  match: "*[2][.='_' or .='¬Ø']"
  replace:
  - test:
      if: "$LaTeX_UseShortName"
      then: [t: "\\ol{"]
      else: [t: "\\overline{"]
  - x: "*[1]"
  - t: "}"

-
  name: "vector"
  tag: "mover"
  match: "*[2][.='‚Üí']"
  replace:
  - t: "\\vec{"
  - x: "*[1]"
  - t: "}"

-
  name: pseudo-scripts
  tag: "msup"
  match: "*[2][translate(., \"'‚Ä≤‚Ä≥‚Ä¥‚Åó¬∞\", '')='']"
  replace:
  - x: "*[1]"
  - x: "*[2]"


-
  name: "default"
  tag: [msub, munder, msup, mover, msubsup, munderover]
  match: "."
  replace:
  - x: "*[1]"
  - test:
      if: "self::m:msup or self::m:mover"
      then: [t: "^"]
      else: [t: "_"]
  - test:
      if: "*[2][IsNode(., 'leaf') and string-length(.) = 1]"
      then: [x: "*[2]"]
      else:
      - t: "{"
      - x: "*[2]"
      - t: "}"
  - test:
      if: "self::m:msubsup or self::m:munderover"
      then:
      - t: "^"
      - test:
          if: "*[3][IsNode(., 'leaf') and string-length(.) = 1]"
          then: [x: "*[3]"]
          else:
          - t: "{"
          - x: "*[3]"
          - t: "}"
  - t: "ùêñ"    # need to separate script from what follows
-
  name: default
  tag: mmultiscripts
  match: "."
  variables:
  # computing the number of postscripts is messy because of <mprescripts> being optionally present -- we use "mod" to get the count right
  - Prescripts: "m:mprescripts/following-sibling::*"
  - NumChildren: "count(*)"       # need to stash this since the count is wrong inside '*[...]' below
  - Postscripts: "*[position()>1 and position() < (last() + ($NumChildren mod 2) -count($Prescripts))]"
  replace:
  - test:
      if: "$Prescripts"
      then:
      - test:
          if: "preceding-sibling::*"
          then: [t: "{}"]         # empty base not needed if this is the only expr
      - test:
          if: "not(DEBUG($Prescripts[1])[self::m:none])"
          then_test:
              if: "$Prescripts[1][IsNode(., 'leaf') and string-length(.) = 1]"
              then: [x: "$Prescripts[1]"]
              else:
              - t: "_{"
              - x: "$Prescripts[1]"
              - t: "}"
      - test:
          if: "not($Prescripts[2][self::m:none])"
          then_test:
              if: "$Prescripts[2][IsNode(., 'leaf') and string-length(.) = 1]"
              then: [x: "$Prescripts[2]"]
              else:
              - t: "^{"
              - x: "$Prescripts[2]"
              - t: "}"
      - test:
          if: "count($Prescripts)>2"
          then:
          - test:
              if: "not($Prescripts[3][self::m:none])"
              then_test:
                  if: "$Prescripts[3][IsNode(., 'leaf') and string-length(.) = 1]"
                  then: [x: "$Prescripts[3]"]
                  else:
                  - t: "_{"
                  - x: "$Prescripts[3]"
                  - t: "}"
          - test:
              if: "not($Prescripts[4][self::m:none])"
              then_test:
                  if: "$Prescripts[4][IsNode(., 'leaf') and string-length(.) = 1]"
                  then: [x: "$Prescripts[4]"]
                  else:
                  - t: "^{"
                  - x: "$Prescripts[4]"
                  - t: "}"
          - test:
              if: "count($Prescripts) > 4"   # give up and just dump them out so at least the content is there
              then: [x: "$Prescripts[position() > 4]"]

  - x: "*[1]"
  - test:
      if: "$Postscripts"
      then:
      - test:
          if: "not($Postscripts[1][self::m:none])"
          then_test:
              if: "$Postscripts[1][IsNode(., 'leaf') and string-length(.) = 1]"
              then: [x: "$Postscripts[1]"]
              else:
              - t: "_{"
              - x: "$Postscripts[1]"
              - t: "}"
      - test:
          if: "not($Postscripts[2][self::m:none])"
          then_test:
              if: "$Postscripts[2][IsNode(., 'leaf') and string-length(.) = 1]"
              then: [x: "$Postscripts[2]"]
              else:
              - t: "^{"
              - x: "$Postscripts[2]"
              - t: "}"
      - test:
          if: "count($Postscripts)>2"
          then:
          - test:
              if: "not($Postscripts[3][self::m:none])"
              then_test:
                  if: "$Postscripts[3][IsNode(., 'leaf') and string-length(.) = 1]"
                  then: [x: "$Postscripts[3]"]
                  else:
                  - t: "_{"
                  - x: "$Postscripts[3]"
                  - t: "}"
          - test:
              if: "not($Postscripts[4][self::m:none])"
              then_test:
                  if: "$Postscripts[4][IsNode(., 'leaf') and string-length(.) = 1]"
                  then: [x: "$Postscripts[4]"]
                  else:
                  - t: "^{"
                  - x: "$Postscripts[4]"
                  - t: "}"
          - test:
              if: "count($Postscripts)>4"
              then:
              - test:
                  if: "not($Postscripts[5][self::m:none])"
                  then_test:
                      if: "$Postscripts[5][IsNode(., 'leaf') and string-length(.) = 1]"
                      then: [x: "$Postscripts[5]"]
                      else:
                      - t: "_{"
                      - x: "$Postscripts[5]"
                      - t: "}"
              - test:
                  if: "not($Postscripts[6][self::m:none])"
                  then_test:
                      if: "$Postscripts[6][IsNode(., 'leaf') and string-length(.) = 1]"
                      then: [x: "$Postscripts[6]"]
                      else:
                      - t: "^{"
                      - x: "$Postscripts[6]"
                      - t: "}"
              - test:
                  if: "count($Postscripts)>6"
                  then:
                  - test:
                      if: "not($Postscripts[7][self::m:none])"
                      then_test:
                          if: "$Postscripts[7][IsNode(., 'leaf') and string-length(.) = 1]"
                          then: [x: "$Postscripts[7]"]
                          else:
                          - t: "_{"
                          - x: "$Postscripts[7]"
                          - t: "}"
                  - test:
                      if: "not($Postscripts[8][self::m:none])"
                      then_test:
                          if: "$Postscripts[8][IsNode(., 'leaf') and string-length(.) = 1]"
                          then: [x: "$Postscripts[8]"]
                          else:
                          - t: "^{"
                          - x: "$Postscripts[8]"
                          - t: "}"
                  - test:
                      if: "count($Postscripts) > 8"   # give up and just dump them out so at least the content is there
                      then:
                      - x: "$Postscripts[position() > 8]"
  - t: "ùêñ"    # need to separate script from what follows
                

-
  # Note: @notation can contain more than one value
  # I don't think UEB has a good way to represent all notations, especially when in combination
  # Note:
  #   Shape indicator: ‚†´
  #   Physical enclosure: ‚†™  (think plus inside of a circle)
  #   Superposition indicator: ‚†Ø  (think contour integral)
  #   Cancellation: ‚†à‚†± (line through previous char -- will use for horizontal, vertical, diagonal lines)
  #   Line over/under: use GTM 12 bar rule (over ‚†±, under ‚††‚†±)
  #   Horizontal juxtaposition indicator: ‚†ø
  #   Vertical juxtaposition indicator: ‚†ª (think ‚âó)
  #   Termination indicator: ‚†± 
  #
  # We place left and right outside of other notations
  # Boxes and circle are does as physical enclosure (shape before base)
  # Arrows are done as superposition (after base)
  # top and bottom are done as "bars" (GTM 12) (after base)

  name: default
  tag: menclose
  match: "."
  # FIX: can't find a rule that says anything about comparison operator spacing and enclosure
  variables: [AddSpaces: "parent::*[self::m:mrow] and *[1][ self::m:mo and IsInDefinition(., 'NemethComparisonOperators')]"]
  replace:
  - test:
      if: "contains(concat(' ', normalize-space(@notation), ' '), ' left ')"                  #avoid 'leftarrow'
      then: [t: "‚†∏"]
  - test:
      if: "contains(@notation,'box')"                  # box and roundedbox
      then:
      # - test:
      #       if: "$AddSpaces"
      #       then: [t: "ùêñ"]
      - t: "1‚†´‚†º‚†ô"                                  # square (no rectangle in UEB)
  - test:
      if: "contains(@notation,'circle')"
      then:
      # - test:
      #    if: "$AddSpaces"
      #    then: [t: "ùêñ"]
      - t: "1‚†´‚†ø"                                  # circle (no oval in UEB)
# ??? What should happen with arrow?
#  If there is a box/circle with arrows only and an empty child,
#     then it acts like the arrow is the child
#  If there are only arrows for 'notation', then maybe rule 112 applies (superposition),
#     but the examples aren't similar. In that case, the arrow acts like 'box' and the child is the content... maybe  
# 
#  - test:
#      if: "contains(@notation,'leftarrow')"
#      then: [t: left arrow, pause: short]
#  - test:
#      if: "contains(concat(' ', normalize-space(@notation), ' '), ' rightarrow ')"
#      then: [t: right arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northeastarrow')"
#      then: [t: northeast arrow, pause: short]
#  - test:
#      if: "contains(concat(' ', normalize-space(@notation), ' '), ' southeastarrow ')"
#      then: [t: southeast arrow, pause: short]
#  - test:
#      if: "contains(concat(' ', normalize-space(@notation), ' '), ' southwestarrow ')"
#      then: [t: southwest arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northwestarrow')"
#      then: [t: northwest arrow, pause: short]
#  - test:
#      if: "contains(@notation,'updownarrow')"
#      then: [t: double ended vertical arrow, pause: short]
#  - test:
#      if: "contains(@notation,'leftrightarrow')"
#      then: [t: double ended horizontal arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northeastsouthwestarrow')"
#      then: [t: double ended up diagonal arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northwestsoutheastarrow')"
#      then: [t: double ended down diagonal arrow, pause: short]
#  - test:
#      if: ".[contains(@notation,'actuarial')]"
#      then: [t: actuarial symbol, pause: short]
#  - test:
#      if: ".[contains(@notation,'madrub')]"
#      then: [t: arabic factorial symbol, pause: short]
#  - test:
#      if: ".[contains(@notation,'longdiv') or not(@notation) or normalize-space(@notation) ='']"      # default
#      then: [t: long division symbol, pause: short]
#  - test:
#      if: ".[contains(@notation,'radical')]"
#      then: [t: square root, pause: short]

  - test:
      if: "NeedsToBeGrouped(*[1], 'UEB', false())"
      then:
      - t: "'{'"
      - x: "*[1]"
      - t: "'}'"
      else: [x: "*[1]"]

  # - test:
  #    if: "contains(@notation,'phasorangle')"  #FIX: what should this be???
  #    then: [t: "‚†´‚†™‚†∏‚†´"]
  - test:
      if: "contains(@notation,'arrow')"    # all the arrows
      then:
      - test:
          - if: "contains(@notation,'rightarrow')" 
            then: [t: "1‚†≥‚†ï"]                                                           
          - else_if: "contains(@notation,'leftarrow')" 
            then: [t: "1‚†≥‚†™"]                                                           
          - else_if: "contains(@notation,'uparrow')" 
            then: [t: "1‚†≥‚†¨ùêñ"]                                                           
          - else_if: "contains(@notation,'downarrow')" 
            then: [t: "1‚†≥‚†©"]                                                           
          - else_if: "contains(@notation,'northeastarrow')" 
            then: [t: "1‚†≥‚†é"]                                                           
          - else_if: "contains(@notation,'southeastarrow')" 
            then: [t: "1‚†≥‚†£"]                                                           
          - else_if: "contains(@notation,'northwestarrow')" 
            then: [t: "1‚†≥‚†±"]                                                           
          - else_if: "contains(@notation,'southwestarrow')" 
            then: [t: "1‚†≥‚†ú"]                                                           
          - else_if: "contains(@notation,'leftrightarrow')" 
            then: [t: "1‚†≥‚†∫‚†ó‚†ï"]                                                           
          - else_if: "contains(@notation,'updownarrow')" 
            then: [t: "1‚†≥‚†∫‚†ó‚†¨"]                                                           
          - else_if: "contains(@notation,'northeastsouthwestarrow')" 
            then: [t: "1‚†≥‚†∫‚†ó‚†é"]                                                           
          - else_if: "contains(@notation,'northwestsoutheastarrow')" 
            then: [t: "1‚†≥‚†∫‚†ó‚†£"]                                                           
  - test:
      if: "contains(@notation,'top')"
      then: [t: "‚†±"]                                                                
  - test:
      if: "contains(@notation,'bottom')"
      then: [t: "‚††‚†±"]                                                                
  - test:
      if: "contains(@notation,'updiagonalstrike') or contains(@notation,'downdiagonalstrike') or 
            contains(@notation,'verticalstrike') or contains(@notation,'horizontalstrike')"
      then:
      - t: "1‚†à‚†±"                        # cancellation
  - test:
      if:
      - "not($AddSpaces) and contains(@notation,'box') or contains(@notation,'circle') or"
      - "contains(@notation,'arrow') or contains(@notation,'phasorangle')" 
      then:
      - t: "‚†ª"                   # terminate shape
    # - test:
    #    if: "$AddSpaces"
    #    then: [t: "ùêñ"]
  - test:
      if: "contains(concat(' ', normalize-space(@notation), ' '), ' right ')"                  #avoid 'rightarrow'
      then: [t: "‚†∏"]

-
  name: default
  tag: ms
  match: "."
  replace:
    - test:
        if: "string(@lquote)!=''"
        then: [x: "@lquote"]
        else: [t: "‚†Ñ‚†Ñ"]
    - x: "BrailleChars(., 'UEB')"
    - test:
        if: "string(@rquote)!=''"
        then: [x: "@rquote"]
        else: [t: "‚†Ñ‚†Ñ"]

-
  name: default
  tag: semantics
  match: "."
  replace: 
    - x: "*[1]"             #/ FIX: should prioritize @encoding="MathML-Presentation" and @encoding="application/mathml-presentation+xml"

-
  name: default-children
  tag: "*"
  match: "*"    # make sure there are children
  replace: 
  - t: "unknown math m l element"
  - x: "name(.)"
  - x: "*"

-
  # at this point, we know there are no children -- might be no text
  name: default-no-children
  tag: "*"
  match: "text()"
  replace: 
  - t: unknown math m l element
  - x: "name(.)"
  - x: "text()"

-
  name: default-no-text
  tag: "*"
  match: "."
  replace: 
  - t: "empty unknown math m l element"
  - x: "name(.)"
