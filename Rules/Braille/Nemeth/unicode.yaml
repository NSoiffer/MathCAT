---
# To greatly simplify typeface/language generation, the chars have unique ASCII chars for them:
# Typeface: S: sans-serif, B: bold, T: script/blackboard, I: italic, R: Roman
# Language: E: English, D: German, G: Greek, V: Greek variants, H: Hebrew, U: Russian
# Indicators: C: capital, L: letter, N: number, P: punctuation, M: multipurpose
# Others: W -- whitespace that should be kept (e.g, in a numeral)
#  SRE doesn't have H: Hebrew or U: Russian, so not encoded (yet)
# Some of the weird letters (e.g., circled letters) I didn't translate with the above because
#   they don't interact with rules since they are enclosed in other chars.


  # --- Nemeth Default Alphabet normal chars. ---
 - "0": [t: "N‚†¥"]               # 0x30
 - "1": [t: "N‚†Ç"]               # 0x31
 - "2": [t: "N‚†Ü"]               # 0x32
 - "3": [t: "N‚†í"]               # 0x33
 - "4": [t: "N‚†≤"]               # 0x34
 - "5": [t: "N‚†¢"]               # 0x35
 - "6": [t: "N‚†ñ"]               # 0x36
 - "7": [t: "N‚†∂"]               # 0x37
 - "8": [t: "N‚†¶"]               # 0x38
 - "9": [t: "N‚†î"]               # 0x39
 - "A": [t: "CL‚†Å"]              # 0x41
 - "B": [t: "CL‚†É"]              # 0x42
 - "C": [t: "CL‚†â"]              # 0x43
 - "D": [t: "CL‚†ô"]              # 0x44
 - "E": [t: "CL‚†ë"]              # 0x45
 - "F": [t: "CL‚†ã"]              # 0x46
 - "G": [t: "CL‚†õ"]              # 0x47
 - "H": [t: "CL‚†ì"]              # 0x48
 - "I": [t: "CL‚†ä"]              # 0x49
 - "J": [t: "CL‚†ö"]              # 0x4a
 - "K": [t: "CL‚†Ö"]              # 0x4b
 - "L": [t: "CL‚†á"]              # 0x4c
 - "M": [t: "CL‚†ç"]              # 0x4d
 - "N": [t: "CL‚†ù"]              # 0x4e
 - "O": [t: "CL‚†ï"]              # 0x4f
 - "P": [t: "CL‚†è"]              # 0x50
 - "Q": [t: "CL‚†ü"]              # 0x51
 - "R": [t: "CL‚†ó"]              # 0x52
 - "S": [t: "CL‚†é"]              # 0x53
 - "T": [t: "CL‚†û"]              # 0x54
 - "U": [t: "CL‚†•"]              # 0x55
 - "V": [t: "CL‚†ß"]              # 0x56
 - "W": [t: "CL‚†∫"]              # 0x57
 - "X": [t: "CL‚†≠"]              # 0x58
 - "Y": [t: "CL‚†Ω"]              # 0x59
 - "Z": [t: "CL‚†µ"]              # 0x5a
 - "a": [t: "L‚†Å"]               # 0x61
 - "b": [t: "L‚†É"]               # 0x62
 - "c": [t: "L‚†â"]               # 0x63
 - "d": [t: "L‚†ô"]               # 0x64
 - "e": [t: "L‚†ë"]               # 0x65
 - "f": [t: "L‚†ã"]               # 0x66
 - "g": [t: "L‚†õ"]               # 0x67
 - "h": [t: "L‚†ì"]               # 0x68
 - "i": [t: "L‚†ä"]               # 0x69
 - "j": [t: "L‚†ö"]               # 0x6a
 - "k": [t: "L‚†Ö"]               # 0x6b
 - "l": [t: "L‚†á"]               # 0x6c
 - "m": [t: "L‚†ç"]               # 0x6d
 - "n": [t: "L‚†ù"]               # 0x6e
 - "o": [t: "L‚†ï"]               # 0x6f
 - "p": [t: "L‚†è"]               # 0x70
 - "q": [t: "L‚†ü"]               # 0x71
 - "r": [t: "L‚†ó"]               # 0x72
 - "s": [t: "L‚†é"]               # 0x73
 - "t": [t: "L‚†û"]               # 0x74
 - "u": [t: "L‚†•"]               # 0x75
 - "v": [t: "L‚†ß"]               # 0x76
 - "w": [t: "L‚†∫"]               # 0x77
 - "x": [t: "L‚†≠"]               # 0x78
 - "y": [t: "L‚†Ω"]               # 0x79
 - "z": [t: "L‚†µ"]               # 0x7a
 - "Œë": [t: "GCL‚†Å"]             # 0x391
 - "Œí": [t: "GCL‚†É"]             # 0x392
 - "Œì": [t: "GCL‚†õ"]             # 0x393
 - "Œî": [t: "GCL‚†ô"]             # 0x394
 - "Œï": [t: "GCL‚†ë"]             # 0x395
 - "Œñ": [t: "GCL‚†µ"]             # 0x396
 - "Œó": [t: "GCL‚†±"]             # 0x397
 - "Œò": [t: "GCL‚†π"]             # 0x398
 - "Œô": [t: "GCL‚†ä"]             # 0x399
 - "Œö": [t: "GCL‚†Ö"]             # 0x39a
 - "Œõ": [t: "GCL‚†á"]             # 0x39b
 - "Œú": [t: "GCL‚†ç"]             # 0x39c
 - "Œù": [t: "GCL‚†ù"]             # 0x39d
 - "Œû": [t: "GCL‚†≠"]             # 0x39e
 - "Œü": [t: "GCL‚†ï"]             # 0x39f
 - "Œ†": [t: "GCL‚†è"]             # 0x3a0
 - "Œ°": [t: "GCL‚†ó"]             # 0x3a1
 - "œ¥": [t: "GCL‚†π"]             # 0x3f4
 - "Œ£": [t: "GCL‚†é"]             # 0x3a3
 - "Œ§": [t: "GCL‚†û"]             # 0x3a4
 - "Œ•": [t: "GCL‚†•"]             # 0x3a5
 - "Œ¶": [t: "GCL‚†ã"]             # 0x3a6
 - "Œß": [t: "GCL‚†Ø"]             # 0x3a7
 - "Œ®": [t: "GCL‚†Ω"]             # 0x3a8
 - "Œ©": [t: "GCL‚†∫"]             # 0x3a9
 - "‚àá": [t: "GL‚†´"]              # 0x2207
 - "Œ±": [t: "GL‚†Å"]              # 0x3b1
 - "Œ≤": [t: "GL‚†É"]              # 0x3b2
 - "Œ≥": [t: "GL‚†õ"]              # 0x3b3
 - "Œ¥": [t: "GL‚†ô"]              # 0x3b4
 - "Œµ": [t: "GL‚†ë"]              # 0x3b5
 - "Œ∂": [t: "GL‚†µ"]              # 0x3b6
 - "Œ∑": [t: "GL‚†±"]              # 0x3b7
 - "Œ∏": [t: "GL‚†π"]              # 0x3b8
 - "Œπ": [t: "GL‚†ä"]              # 0x3b9
 - "Œ∫": [t: "GL‚†Ö"]              # 0x3ba
 - "Œª": [t: "GL‚†á"]              # 0x3bb
 - "Œº": [t: "GL‚†ç"]              # 0x3bc
 - "ŒΩ": [t: "GL‚†ù"]              # 0x3bd
 - "Œæ": [t: "GL‚†≠"]              # 0x3be
 - "Œø": [t: "GL‚†ï"]              # 0x3bf
 - "œÄ": [t: "GL‚†è"]              # 0x3c0
 - "œÅ": [t: "GL‚†ó"]              # 0x3c1
 - "œÇ": [t: "VL‚†é"]              # 0x3c2
 - "œÉ": [t: "GL‚†é"]              # 0x3c3
 - "œÑ": [t: "GL‚†û"]              # 0x3c4
 - "œÖ": [t: "GL‚†•"]              # 0x3c5
 - "œÜ": [t: "VL‚†ã"]              # 0x3c6
 - "œá": [t: "GL‚†Ø"]              # 0x3c7
 - "œà": [t: "GL‚†Ω"]              # 0x3c8
 - "œâ": [t: "GL‚†∫"]              # 0x3c9
 - "‚àÇ": [t: "‚†à‚†ô"]               # 0x2202
 - "œµ": [t: "GL‚†ë"]              # 0x3f5
 - "œë": [t: "VL‚†π"]              # 0x3d1
 - "œ∞": [t: "GL‚†Ö"]              # 0x3f0
 - "œï": [t: "GL‚†ã"]              # 0x3d5
 - "œ±": [t: "GL‚†ó"]              # 0x3f1
 - "œñ": [t: "GL‚†è"]              # 0x3d6


  # --- Nemeth Default Characters math_symbols chars. ---
 - "`": [t: "‚†à"]                # 0x60
 - "‚âü": [t: "‚†ê‚†®‚†Ö‚†£‚†∏‚†¶‚†ª"]       # 0x225f
 - "‚â†": [t: "‚†å‚†®‚†Ö"]             # 0x2260
 - "‚â°":                         # 0x2261
    - test:
        if: "@data-chemical-bond"
        then: [t: "‚†∏‚†ø‚†ª"]
        else: [t: "‚†∏‚†á"]

 - "‚â§": [t: "‚†ê‚†Ö‚†±"]              # 0x2264
 - "‚â•": [t: "‚†®‚†Ç‚†±"]              # 0x2265
 - "‚äÇ": [t: "‚†∏‚†ê‚†Ö"]              # 0x2282
 - "‚äÉ": [t: "‚†∏‚†®‚†Ç"]              # 0x2283
 - "‚äÑ": [t: "‚†å‚†∏‚†ê‚†Ö"]             # 0x2284
 - "‚äÖ": [t: "‚†å‚†∏‚†®‚†Ç"]             # 0x2285
 - "‚äÜ": [t: "‚†∏‚†ê‚†Ö‚†±"]             # 0x2286
 - "‚äá": [t: "‚†∏‚†®‚†Ç‚†±"]             # 0x2287
 - "‚ä•": [t: "‚†´‚†è"]               # 0x22a5
 - "‚ãÄ": [t: "‚†à‚†©"]               # 0x22c0
 - "‚ãÅ": [t: "‚†à‚†¨"]               # 0x22c1
 - "‚ãÇ": [t: "‚†®‚†©"]               # 0x22c2
 - "‚ãÉ": [t: "‚†®‚†¨"]               # 0x22c3
 - "‚ãÖ": [t: "‚†°"]                # 0x22c5
 - "‚ãú": [t: "‚†±‚†ê‚†Ö"]              # 0x22dc
 - "‚ãù": [t: "‚†±‚†®‚†Ç"]              # 0x22dd
 - "‚ãÆ": [t: "‚†£‚†Ñ‚†Ñ‚†Ñ"]             # 0x22ee
 - "‚ãØ": [t: "‚†Ñ‚†Ñ‚†Ñ"]              # 0x22ef
 - "‚ã∞": [t: "‚†ò‚†Ñ‚†Ñ‚†Ñ"]             # 0x22f0
 - "‚ã±": [t: "‚†∞‚†Ñ‚†Ñ‚†Ñ"]             # 0x22f1

  # --- Nemeth Default Characters rest chars. ---
 - "‚Üê": [t: "‚†´‚†™‚†í‚†í"]             # 0x2190
 - "‚ÖÜ": [t: "‚†ô"]                # 0x2146
 - "‚Öá": [t: "‚†ë"]                # 0x2147
 - "‚Öà": [t: "‚†ä"]                # 0x2148
 - "(": [t: "‚†∑"]                # 0x28
 - ")": [t: "‚†æ"]                # 0x29
 - "[": [t: "‚†à‚†∑"]               # 0x5b
 - "]": [t: "‚†à‚†æ"]               # 0x5d
 - "{": [t: "‚†®‚†∑"]               # 0x7b
 - "}": [t: "‚†®‚†æ"]               # 0x7d
 - "‚åà": [t: "‚†à‚†ò‚†∑"]              # 0x2308
 - "‚åâ": [t: "‚†à‚†ò‚†æ"]              # 0x2309
 - "‚åä": [t: "‚†à‚†∞‚†∑"]              # 0x230a
 - "‚åã": [t: "‚†à‚†∞‚†æ"]              # 0x230b


 # overwrites from MS
   # space inside of numbers has special treatment
 - " ":                        # 0x20 (space)
    - test:
        if: "self::m:mn"
        then: [t: "‚†Ä"]
        else: [t: "W"]

 - "¬†":                        # 0xA0 (non-breaking space)
    - test:
        if: "self::m:mn"
        then: [t: "‚†Ä"]
        else: [t: "W"]
 - "!":                          # 0x21 (Factorial)
    - test:
        if: "self::m:mo"
        then: [t: "‚†Ø"]
        else: [t: "P‚†ñ"]

#  - "\"": [t: ""]                # 0x22 (Quotation mark)
 - "#": [t: "‚†®‚†º"]               # 0x23 (Number sign)
 - "$": [t: "‚†à‚†é"]               # 0x24 (Dollar sign)
 - "%": [t: "‚†à‚†¥"]               # 0x25 (Percent sign)
 - "&": [t: "‚†∏‚†Ø"]               # 0x26 (Ampersand)
 - "'": [t: "P‚†Ñ"]                # 0x27 (Apostrophe)
 - "(": [t: "‚†∑"]                # 0x28 (Left parenthesis)
 - ")": [t: "‚†æ"]                # 0x29 (Right parenthesis)
 - "*": [t: "‚†à‚†º"]               # 0x002A (Asterisk)
 - "+":                         # 0x002B (Plus sign)
    - test:
        # Add multipurpose indicator before prefix '+' to avoid being the same as '‚àì' 
        if: "not(preceding-sibling::*) and parent::*[1][name(.)='mrow' and preceding-sibling::*[1][name(.)='mo' and text()='-']]"
        then: [t: "m‚†¨"]
        else: [t: "‚†¨"]

 - ",":                         # 0x002C (Comma)
    - test:
          # test if first ancestor that isn't an mrow is a script tag (rule 78)
      - if: "self::m:mn"
        then: [t: "‚††"]
      - else_if: "ancestor-or-self::*[not(parent::m:mrow)][1][parent::m:msub or parent::m:msup or parent::m:msubsup or parent::m:mmultiscripts][preceding-sibling::*]"
        then: [t: "‚†™"]         # Rule 78
        else: [t: ","]         # ',' used for matching purposes, converted to "‚††‚†Ä"
 - "-":                        # 0x002D (Hyphen)  (0x2212 normalized to here) -- 38vi says don't use the punctuation indicator
    - test:
        # Add multipurpose indicator before prefix '+' to avoid being the same as '¬±' or a dash
        if: "@data-chemical-bond"
        then: [t: "‚†∏‚†í‚†ª"]
        else_test:
            if: "not(preceding-sibling::*) and parent::*[1][name(.)='mrow' and preceding-sibling::*[1][name(.)='mo' and (text()='+' or text()='-')]]"
            then: [t: "m‚†§"]
            else: [t: "‚†§"] 

 - ".":                          # 0x002E (Full stop or decimal pt)
      # '.' is particularly tricky because we need to know if it is really numeric or not.
      # if it is numeric, it might be a on it's own or part of a number.
      # normally, it is merged with the digits if part of a number, but if the adjacent digit(s) are modified
      #  by something (e.g., a bar over the digit to signify that it repeats), then it is really part of the number
      # If it is the last part of the expr, then it is punctuation (for typographic reasons, punctuation is often included in the math)
    - test:
        if: "self::m:mn or (self::m:mo and following-sibling::*)"
        then_test:
          if: "string-length(text()) = 1 and not(
                  following-sibling::*[1][BaseNode(.)[self::m:mn]] or
                  following-sibling::*[1][self::m:menclose and @notation='top' and *[1][self::m:mn]]
              )"
          then: [t: "ùëÅ‚†®"]      # example 8c(4) -- lone "." is not considered numeric, but not a period
          else: [t: "N‚†®"]
        else_test:
          if: "preceding-sibling::*[1][@data-roman-numeral or
                  (name(.)='mrow' and *[last()][@data-roman-numeral])]"
          then: [t: "ùêè‚†≤"]
          else: [t: "P‚†≤"]
 - "/": [t: "‚†∏‚†å"]               # 0x002F (Solidus)
 - ":":                         # 0x003A (Colon)
        # sometimes a colon is meant to be a ratio
        # this test is based on what SRE does -- if the "roles" are the same, it guesses "ratio"
        # MathCAT doesn't have roles, so we do a hack that looks checks mrows if not atomic.
        # If an mrow, guess it is infix and checks the operator. This is pretty weak!
        # Need to rule out field extensions "[K:F]" and trilinear coordinates "a:b:c" as they use the punctuation form
        # When using the punctuation form, there may or may not be a trailing spacing depending on the "print"
        #   NFB Lesson 5.7 says "Follow print for spacing after the colon."
        #   We can't normally tell spacing, but it *should* have a space in function mapping and set builder notation if the author used appropriate notation
        #   The canonicalization code makes this guess and adds "data-space-after"
    - test:
        if: "not(IsBracketed(ancestor::*[2], '[', ']')) and
             not( preceding-sibling::*[2][text()=':'] or following-sibling::*[2][text()=':']) and 
             name(preceding-sibling::*[1]) = name(following-sibling::*[1]) and
             ( name(preceding-sibling::*[1]) != 'mrow' or
               (preceding-sibling::*[1]/*[2][text()] = following-sibling::*[1]/*[2][text()]) )"
        then: [t: "W‚†ê‚†ÇW"]
        else:
        - t: "P‚†í"
        - test:
            if: "@data-space-after or IsBracketed(ancestor::*[2], '{', '}') or following-sibling::*[1]/*[2][IsInDefinition(., 'Arrows')]" # "Arrows" is a bit broad...
            then: [t: "W"]
 - ";": [t: "P‚†Ü"]               # 0x003B (Semicolon)
 - "<": [t: "‚†ê‚†Ö"]             # 0x003C (Less-than sign)
 - "=":                        # 0x003D (Equals sign)
    - test:
        if: "@data-chemical-bond"
        then: [t: "‚†∏‚†∂‚†ª"]
        else: [t: "‚†®‚†Ö"]

 - ">": [t: "‚†®‚†Ç"]             # 0x003E (Greater-than sign)
 - "?": [t: "P‚†¶"]               # 0x003F (Question mark)
 - "@": [t: "‚†à‚†Å"]               # 0x40 (Commercial at)
 - "[": [t: "‚†à‚†∑"]               # 0x005B (Left square bracket)
 - "\\": [t: "‚†∏‚†°"]              # 0x005C (Reverse solidus)
 - "]": [t: "‚†à‚†æ"]               # 0x005D (Right square bracket)
 - "^": [t: "‚†∏‚†£"]               # 0x005E (Circumflex accent)
 - "_": [t: ""]                 # 0x005F (Low line)
 - "{": [t: "‚†®‚†∑"]               # 0x007B (Left curly bracket)
 - "|":                # 0x007C (Vertical line)
     - test:
        if: "preceding-sibling::* and following-sibling::*"
        then: [t: "w‚†≥w"]        # comparison (e.g., such that -- rule 145)
        else: [t: "‚†≥"]          # absolute value, others???
 - "}": [t: "‚†®‚†æ"]               # 0x007D (Right curly bracket)
 - "~": [t: "‚†à‚†±"]               # 0x007E (Tilde)
 - "¬¢": [t: "‚†à‚†â"]               # 0x00A2 (Cent sign)
 - "¬£": [t: "‚†à‚†á"]               # 0x00A3 (Pound sterling)
 - "¬ß": [t: "‚†à‚††‚†é"]              # 0x00A7 (Section sign)
 - "¬©": [t: "‚†∑‚††‚†â‚†æ"]             # 0x00A9 (Copyright sign)
 - "¬¨": [t: ""]                 # 0x00AC (Not sign)
 - "¬Ø": [t: "‚†±"]                # 0x00AF (bar)
 - "¬∞": [t: "‚†®‚†°"]              # 0x00B0 (Degree sign)
 - "¬±": [t: "‚†¨‚†§"]               # 0x00B1 (Plus-minus sign)
 - "¬∂": [t: "‚†à‚††‚†è"]              # 0x00B6 (Pilcrow sign)
 - "¬∑": [t: "‚†°"]                # 0x00B7 (Middle dot)
 - "√ó": [t: "‚†à‚†°"]               # 0x00D7 (Multiplication sign)
 - "√∑": [t: "‚†®‚†å"]               # 0x00F7 (Division sign)
 - "‚Äî": [t: "P‚†§‚†§"]               # 0x2014 (Em dash)
      # rule 43b about spaces (references rule 42)
      # dashes are 'mo's so no inserted invisible times between it and currency symbols
 - "‚Äï":                          # 0x2015 (Horizontal bar)
    - test:
        if:
          - "not("
          - "  (not(preceding-sibling::*) and parent::*[1][name(.)='mrow' and preceding-sibling::*[1][IsInDefinition(., 'NemethPunctAndOpenBeforeSymbols')]]) or"
          - "  (preceding-sibling::*[1][IsInDefinition(., 'NemethCurrencyBeforeSymbols')])"
          - ")"
        then: [t: "W"]
    - t: "‚†§‚†§‚†§‚†§"
    - test:
        if:
          - "not("
          - "  name(parent::*[1])='mrow' and ("
          - "    (following-sibling::*[1][IsInDefinition(., 'NemethPunctAndOpenAfterSymbols')]) or "
          - "    (not(following-sibling::*) and parent::*[1][name(.)='mrow' and following-sibling::*[1][IsInDefinition(., 'NemethPunctAndOpenAfterSymbols')]]) or "
          - "    (following-sibling::*[1][text() = '\u2062'] and following-sibling::*[2][IsInDefinition(., 'NemethCurrencyAfterSymbols')])"
          - "  )"
          - ")"
        then: [t: "W"]

 - "‚Ä¶":                          # 0x2026 (Ellipsis)
      # rule 43b about spaces (references rule 42); partly superseded by lesson 2.13
      # tests are ugly because an invisible times might have been inserted and we need to skip that
    - test:
        if:
          - "not("
          - "  (not(preceding-sibling::*) and parent::*[1][name(.)='mrow' and preceding-sibling::*[1][IsInDefinition(., 'NemethPunctAndOpenBeforeSymbols')]]) or"
          - "  (preceding-sibling::*[1][text() = '\u2062'] and preceding-sibling::*[2][IsInDefinition(., 'NemethCurrencyBeforeSymbols')])"
          - ")"
        then: [t: "W"]
    - t: "‚†Ñ‚†Ñ‚†Ñ"
    - test:
        if:
          - "not("
          - "  name(parent::*[1])='mrow' and ("
          - "    (following-sibling::*[1][IsInDefinition(., 'NemethPunctAndOpenAfterSymbols')]) or "
          - "    (not(following-sibling::*) and parent::*[1][name(.)='mrow' and following-sibling::*[1][IsInDefinition(., 'NemethPunctAndOpenAfterSymbols')]]) or "
          - "    (following-sibling::*[1][text() = '\u2062'] and following-sibling::*[2][IsInDefinition(., 'NemethCurrencyAfterSymbols')])"
          - "  )"
          - ")"
        then: [t: "W"]
 - "‚Ä∞": [t: "`00"]
 - "‚Ä≤": [t: "‚†Ñ"]                # 0x2032 (Prime)
 - "‚Ä≥": [t: "‚†Ñ‚†Ñ"]               # 0x2033 (Double prime)
 - "‚Å°":                         # 0x2061‚Å° (invisible function apply)
    # add a space if name doesn't have brackets after it or is in FunctionNames list 
    - test:
        if: "not(following-sibling::*[1][IsBracketed(., '', '')]) or preceding-sibling::*[1][IsInDefinition(BaseNode(.), 'FunctionNames')]" 
        then: [t: "w"]      # follows a function name, so lowercase
 - "‚Å¢": [t: ""]                  # 0x2062 -- what's right???  "‚†à‚†°" (times) is not right
 - "‚Å£":                         # 0x2063 (Invisible Comma -- treat like a normal comma when in a subscript[issue #40]) else ignore
    - test:
          # test if first ancestor that isn't an mrow is a script tag (rule 78)
      - if: "self::m:mn"
        then: [t: ""]
      - else_if: "ancestor-or-self::*[not(parent::m:mrow)][1][parent::m:msub or parent::m:msup or parent::m:msubsup or parent::m:mmultiscripts][preceding-sibling::*]"
        then: [t: "‚†™"]        # Rule 78
        else: [t: ""]
 - "‚Å§": [t: ""]                 # 0x2064

 - "‚Ñè": [t: "‚†à‚†ì"]               # 0x210F (Planck constant over two pi)
 - "‚Ñì": [t: "TE‚†á"]               # 0x2113 (Script small l (differs from 1d4c1: 4-56-123))
 - "‚Üí":                           # 0x2192 (Rightwards arrow)
     - test:                      # Rule 96 -- uncontracted form if base of under/over
        if: "not(preceding-sibling::*) and parent::*[self::m:mover or self::m:munder or self::m:munderover]"
        then: [t: "‚†´‚†í‚†í‚†ï"]        # uncontracted version
        else: [t: "‚†´‚†ï"]        # contracted version
 - "‚àÄ": [t: "‚†à‚†Ø"]               # 0x2200 (For all)
 - "‚àÇ": [t: "‚†à‚†ô"]               # 0x2202 (Partial differential)
 - "‚àÉ": [t: "‚†à‚†ø"]               # 0x2203 (There exists)
 - "‚àÑ": [t: "‚†å‚†à‚†ø"]              # 0x2204 (There does not exist)
 - "‚àÖ": [t: "‚†∏‚†¥"]               # 0x2205 (Empty set)
 - "‚àè": [t: "‚†®‚††‚†è"]              # 0x220F (N-ary product)
 - "‚àë": [t: "‚†®‚††‚†é"]              # 0x2211 (N-ary summation)
 - "‚àû": [t: "‚††‚†ø"]               # 0x221E (Infinity)
 - "‚àü": [t: "‚†´‚†™‚†®‚†ó‚†ª"]            # 0x221F (Right angle)
 - "‚à†": [t: "‚†´‚†™"]               # 0x2220 (Angle)
 - "‚à°": [t: "‚†´‚†™‚†à‚†´‚†Å‚†ª"]           # 0x2221 (Measured angle)
 - "‚à£": [t: "‚†≥"]              # 0x2223 (Divides)
 - "‚à§": [t: "‚†å‚†≥"]             # 0x2224 (Does not divide)
 - "‚àß": [t: "‚†à‚†©"]               # 0x2227 (Logical AND)
 - "‚à®": [t: "‚†à‚†¨"]               # 0x2228 (Logical OR)
 - "‚à©": [t: "‚†®‚†©"]               # 0x2229 (Intersection)
 - "‚à™": [t: "‚†®‚†¨"]               # 0x222A (Union)
 - "‚à´": [t: "‚†Æ"]                # 0x222B (Integral)
 - "‚à¨": [t: "‚†Æ‚†Æ"]               # 0x222C (Double integral)
 - "‚åà": [t: "‚†à‚†ò‚†∑"]              # 0x2308 (Left ceiling)
 - "‚åâ": [t: "‚†à‚†ò‚†æ"]              # 0x2309 (Right ceiling)
 - "‚åä": [t: "‚†à‚†∞‚†∑"]              # 0x230A (Left floor)
 - "‚åã": [t: "‚†à‚†∞‚†æ"]              # 0x230B (Right floor)
