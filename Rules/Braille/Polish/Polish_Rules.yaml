---
-
  name: spaces
  tag: "!*"
  # 0.8 was chosen as it is larger than 0.7 which is used for a non-breaking space (works for the tests, but I'm not sure that is the best choice)
  match: "not(self::m:math) and not($MatchingWhitespace) and (@data-previous-space-width >= 0.8 or @data-following-space-width >= 0.8)"
  replace:
   - with:
      variables: [MatchingWhitespace: "true()"]
      replace:
      - test:
        - if: "@data-previous-space-width >= 0.8" 
          then: [t: "ùêñ"]
      - x: "."
      - test:
        - if: "@data-following-space-width >= 0.8" 
          then: [t: "ùêñ"]

-
  name: omissions
  tag: "!*"
  match: "contains(@intent, ':blank')"
  replace:
  - test:
      - if: "self::m:mo"
        then: [t: "‚†∞"]      # 14.5(1)
      - else_if: "contains(., '\u00A0')"
        then:   # treated as a number omission -- FIX: anything to look at to increase the odds of it being digits
        - t: "N"
        - x: "translate(., '_\u00A0', '‚†∞')"  # note space is removed
        else: [t: "‚†∞‚†§‚†Ü"]
  - t: ""


-
  name: default
  tag: msqrt
  match: "."
  replace:
  - t: "<‚†©"
  - x: "*[1]"
  - t: ">‚†±"

-
  name: default
  tag: mroot
  match: "."
  replace: 
  - t: "<‚†å"
  - test:
      if: "*[2][self::m:mn][translate(., '0123456789', '') = '']"
      then: [x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
      else: [x: "*[2]"]
  - t: ">‚†±<‚†©"    # '>‚†±' will always get removed due to following projector, but needed for counting depth
  - x: "*[1]"
  - t: ">‚†±"

-
  name: "date"
  # match 15.03.2002, 98/08/26, 2002-03-15, or 2002 03 1, where the year can be 2 or 4 digits and at the start or end
  tag: mrow
  match: "count(*)=5 and
          (*[1][self::m:mn] and *[3][self::m:mn and string-length(.)=2] and *[5][self::m:mn]) and
          ( (*[2][self::m:mo and .='/'] and *[4][self::m:mo and .='/']) or
            (*[2][self::m:mo and .='-'] and *[4][self::m:mo and .='-']) or
            (*[2][self::m:mo and .='.'] and *[4][self::m:mo and .='.'])
          ) and (
            (string-length(*[1])=4 and string-length(*[5])=2) or
            (string-length(*[1])=2 and string-length(*[5])=4) or
            (string-length(*[1])=2 and string-length(*[5])=2) 
          )"
  replace:
  # want to avoid using a number sign after the first one, so we claim the separators are part of numbers
  - x: "*[1]"
  - t: "N"
  - test:
    - if: "*[2][.='.']"
      then: [t: "‚†Ñ"]
    - else_if: "*[2][.='-']"
      then: [t: "‚†§"]
    - else_if: "*[2][.='/']"
      then: [t: "‚†≤"]
      else: [t: "W"]
  - x: "*[3]"
  - t: "N"
  - test:
    - if: "*[2][.='.']"
      then: [t: "‚†Ñ"]
    - else_if: "*[2][.='-']"
      then: [t: "‚†§"]
    - else_if: "*[2][.='/']"
      then: [t: "‚†≤"]
      else: [t: "W"]
  - x: "*[5]"
      

# -   # p43 gives rule for binomial
#   name: binomial
#   tag: mrow
#   match: "IsBracketed(., '(', ')') and
#           *[2][(self::m:mfrac and @linethickness=0) or
#                (self::m:mtable and count(*)=2 and count(*[1])=1 and contains(@intent, 'binomial-coefficient('))]"
#   replace: 
#   - t: "("
#   - t: "<‚†Ü-" # signal start of fraction (needed for fraction depth count -- '-' says to delete the start/end)
#   - x: "*[2]/*[1]"
#   - t: "‚†∞‚†≥"
#   - x: "*[2]/*[2]"
#   - t: ">‚†∞-"
#   - t: ")"

# -
#   longer notation: use if
#     * user chooses long form
#     * nested fraction, as long as the nested fraction is not a common fraction (p30)
#   name: long-form
#   tag: mfrac
#   match:
#     - "not($Polish_UseShortForm) or
#        descendant::*[self::m:mfrac and
#                      not(*[1][self::m:mn][translate(., '0123456789', '') = ''] and *[2][self::m:mn][translate(., '0123456789', '') = ''])]"
#   replace: 
#   - t: "<‚†Ü"
#   - x: "*[1]"
#   - t: "W/W"      # don't use '<W' or '>W' because W acts as terminator
#   - x: "*[2]"
#   - t: ">‚†∞"

-
  name: common-fraction-mixed-number
  tag: mfrac
  match:
    - "$Polish_BrailleLevel = 'Advanced' and preceding-sibling::*[1][self::m:mo][.='\u2064'] and" # preceding element is invisible plus
    - "*[1][self::m:mn][translate(., '0123456789', '') = '']   and" 
    - "*[2][self::m:mn][translate(., '0123456789', '') = '']"
  replace: 
  - t: "#"   # need to force a number sign between the numbers
  - x: "*[1]"
  - x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator

-
  name: simple-number
  tag: mfrac
  match: "$Polish_BrailleLevel = 'Advanced' and *[1][self::m:mn][translate(., '0123456789', '') = ''] and *[2][self::m:mn][translate(., '0123456789', '') = '']"
  replace:
  - x: "*[1]"
  - x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator

- # simpler (more common?) case of the next rule (no whitespace)
  name: simple-fraction
  tag: mfrac
  match: "$Polish_BrailleLevel != 'Beginner' and
          *[1][IsNode(., 'leaf') and not(contains(., 'u00a0'))] and
          *[2][IsNode(., 'leaf') and not(contains(., 'u00a0'))] and
          not(ancestor::*[self::m:mfrac])"
  replace:
  - t: "<‚†Ü-" # signal start of fraction (needed for fraction depth count -- '-' says to delete the start/end)
  - x: "*[1]"
  - t: "/"  # don't need number indicator
  - test:
      if: "$Polish_BrailleLevel = 'Advanced' and *[2][self::m:mn][translate(., '0123456789', '') = '']"
      then:
      - x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator
      else:
      - x: "*[2]"
  - t: ">‚†∞-"

-
  # Rule 1 (p25)
  # no whitespace around the division sign
  name: default
  tag: mfrac
  match: "."
  replace:
  - t: "<‚†Ü" # signal start of fraction (needed for state machine to replace spaces)
  - test:
      # FIX: it seems like this should be more general, but examples break when it is more general
      if: "not(IsNode(*[1], 'leaf')) and preceding-sibling::*[1][self::m:mo and (.='-' or .='+')]"
      then: [t: "+"]   # "+" says to keep the indicator -- need to make sure the "numerator" appears to be in the fraction
  - x: "*[1]"
  - t: "W/"
  - test:
      if: "$Polish_BrailleLevel = 'Advanced' and *[2][self::m:mn][translate(., '0123456789', '') = '']"
      then:
      - x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator
      else:
      - t: "W"
      - x: "*[2]"
  - t: ">‚†∞"


-
  name: linear-numeric-fraction
  tag: mrow
  match: "$Polish_BrailleLevel = 'Advanced' and count(*)=3 and *[2][self::m:mo and .='/'] and
          *[1][self::m:mn][translate(., '0123456789', '') = ''] and *[3][self::m:mn][translate(., '0123456789', '') = '']"
  replace:
  - x: "*[1]"
  - x: "BrailleChars(translate(*[3], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator


#
# Matrix/Determinant rules
# matrix and determinant are the same other than "matrix"/"determinant" based on the bracketing chars
# we don't do spatial layout, instead the beginning/ending of each row uses the enlarged bracketing chars


-
  name: determinant-replacement
  # This replaces W = | ... | with just the determinant content
  # ‚ÄúW‚Äù comes from Polish name "Wyznacznik" (determinant), and this eliminates redundancy (see p46, second form is preferred)
  tag: mrow
  match:
    - "*[1][self::m:mi and .='W' or .='ùêñ'] and *[2][self::m:mo and .='='] and IsBracketed(*[3], '|', '|')"
  replace:
  - t: "‚†ª‚†ô‚†ë‚†û‚†£"   # "det("
  - x: "*[3]/*[2]"
  - t: "‚†ú"        # ")"
  - x: "*[position()>3]"

-
  name: determinant-determinant-replacement
  # This replaces |W| = | | ... | | with just the determinant content
  # ‚ÄúW‚Äù comes from Polish name "Wyznacznik" (determinant), and this eliminates redundancy (see p46, second form is preferred)
  tag: mrow
  match:
    - "IsBracketed(*[1], '|', '|') and *[1]/*[2][self::m:mi and .='W' or .='ùêñ'] and *[2][self::m:mo and .='='] and IsBracketed(*[3], '|', '|')"
  replace:
  - t: "‚†à‚†á‚†ª‚†ô‚†ë‚†û‚†£"   # "|det("
  - x: "*[3]/*[2]/*[2]"
  - t: "‚†ú‚†∏"        # ")"
  - x: "*[position()>3]"


-
  name: default-mtable
  tag: mtable
  match: "."
  replace:
  - x: "*"


-
  name: default
  tag: [mtr, mlabeledtr]
  match: "."
  replace:
  - test: 
      if: "count(parent::*) > 1"
      then: [t: "‚††"]
  - test: 
      if: "preceding-sibling::*"
      then: [t: "‚†∞‚†≥"]
  - test:
      if: .[self::m:mlabeledtr]
      then:
         - t: "‚†ó‚†ï‚†∫W‚†á‚†Å‚†É‚†ë‚†á‚†∏‚†í"  # "row label:"
         - x: "*[1]/*"           # contents of row label
  - test:
      if: .[self::m:mlabeledtr]
      then: [x: "*[position()>1]"]
      else: {x: "*"}
  - test: 
      if: "count(parent::*) > 1"
      then: [t: "‚††"]

-
  name: default
  tag: mtd
  match: "."
  replace:
  - test:
      if: "*"
      then:
      - test: 
         if: "preceding-sibling::*"
         then: [t: "W"]
      - t: "<‚†Ü-" # signal start of fraction (needed for depth count because of tables are off the baseline -- '-' says to delete the start/end)
      - x: "*"
      - t: ">‚†∞-" # not sure if this should be some other indicator; for now using the fraction indicator seems to be ok
      # else nothing to braille

-
  name: no-content
  tag: math
  match: "not(*)"      # empty
  replace: [t: "W"]    # not sure that is right, but this shouldn't happen

-
  name: default
  tag: math
  match: "."
  variables:
    - NewScriptContext: "''"    # empty string -- it needs to be set
    - MatchingWhitespace: "false()"
  replace: [x: "*"]

-
  name: empty-mrow
  tag: mrow
  match: "not(*)"
  replace: [t: "W"] # not sure what is correct -- if in a fraction, probably something is better than nothing

# -
  # 1.3 says that if the character after a closing(?) bar has any of dots 1, 2, or 3, then a blank must be added.
  # The rule should exam the translation of right sibling, but there is no way to do that.
  # The ugly hack is to define a variable lists all the chars with dots in any of position 1, 2, or 3.
  # This is obviously error prone as the list needs to be potentially updated when new chars are added.
  #
  # FIX: I tested the IsInDefinition call for cases when the right child is a structure.
  # It grabs the text of the leftmost child, but this is wrong if some braille indicators come first,
  #   such as a sqrt or implicit grouping. All of these cases have dots in positions 1, 2, or 3.
  #   We do a one level down test for these cases, but it is only a band-aid
  # name: space-after-bar
  # tag: mrow
  # variables: [NextRealChild: "IfThenElse(following-sibling::*[1][.='\u2062'], following-sibling::*[2], following-sibling::*[1])"]
  # match:
  # - "IsBracketed(., '|', '|') and $NextRealChild and"
  # - "( $NextRealChild[self::m:msqrt] or $NextRealChild[self::m:mroot] or"    # have indicator with dots in first half
  # - "  (IsNode($NextRealChild, '2D') and $NextRealChild[*[1][self::m:mrow and not(IsBracketed(., '', ''))]]) or"  # grouping char added which has dots in first half 
  # - "  IsInDefinition(substring($NextRealChild, 1, 1), 'Braille', 'CMUCharsWithDotsOnLeft')"
  # - ")"
  # replace:
  # - x: "*"
  # - t: "W"
  
-
  # Page 29 says to minimize brackets around exprs.
  # The (1/3)^-4 example on p31 shows this, but the p52 cos(alpha/2) examples shows some limits
  # That case shows they aren't needed for a numeric fraction
  # I think the parent case can be msub and msubsup also, but I don't see examples of it (examples p22, 32, 34)
  name: remove-brackets
  tag: mrow
  match: "(IsBracketed(., '(', ')') or IsBracketed(., '[', ']')) and
           *[2][(self::m:mfrac and
                 *[1][self::m:mn and translate(., '0123456789', '') = ''] and
                 *[2][self::m:mn and translate(., '0123456789', '') = '']) or
                (parent::*[parent::m:msup] and (self::m:msub or self::m:subsup))
               ]"
  replace: [x: "*[2]"]
  
-
  name: default
  tag: mrow
  match: "."
  replace: [x: "*"]

# -
#   name: roman_numeral
#   tag: mn
#   match: "@data-roman-numeral or contains(@intent, ':roman-numeral')"
#   replace:
#   # for uppercase, need to only have one as uppercase
#   - x: "BrailleChars(., 'Polish')"
#   - x: "BrailleChars(translate(., 'IVXLCDM', 'ivxlcdm'), 'Polish', 2, string-length(.)+1)"


-
  name: substitute-and-for-i-hack
  # on p18, " i " (with the spaces) is used for '‚àß' 
  # canonicalization moves the spaces into attrs. This only checks for a space which comes from the preceding space.
  #   to check for the following space, we have to skip over a (likely) invisible times
  # for the output, we need to put spaces around the 'i', but we don't want a lower case indicator, so we use private space char hack
  tag: mi
  match: ".='i' and @data-previous-space-width >= 0.7"
  replace:
  - x: "BrailleChars('\ue040', 'Polish')"

-
  name: default
  tag: [mtext, mi]
  match: "."
  variables: [Abbreviations: "DefinitionValue(., 'Braille', 'Abbreviations')"]
  replace:
  - test:
      # Abbreviations take precedence over units and currency symbols (see "rad" on p51), unless they are marked as units
    - if: "$Abbreviations != '' and not(@class='MathML-unit' or contains(@intent, ':unit'))" 
      then:
      - test:
          if: "not(.='const' or .='sgn' or .= 'lim')"
          then: [t: 'f']    # forces function mode (lower case Roman letter)
      - x: "$Abbreviations"
      # add unit indicator
    - else_if: "@class='MathML-unit' or contains(@intent, ':unit') or
           (not(@data-chem-element) and
            (self::m:mtext or string-length(.) > 1 or @mathvariant='normal') and
            (parent::*[1][self::m:mrow and count(*)=3 and *[2][.='\u2062'] and
                          *[1][self::m:mn or
                               (self::m:mfrac and *[1][self::m:mn] and *[2][self::m:mn]) or
                               (self::m:msup and *[1][self::m:mn])
                              ]]) and
            count(preceding-sibling::*) = 2 and 
            (IsInDefinition(., 'Braille', 'SIUnits') or
             IsInDefinition(., 'Braille', 'UnitsWithoutPrefixes') or 
             IsInDefinition(., 'Braille', 'EnglishUnits') or
             (string-length(.) >= 3 and
              substring(., 1, 2) = 'da' and 
              IsInDefinition(substring(., 3), 'Braille', 'SIUnits')) or
             (string-length(.) >= 2 and
              IsInDefinition(substring(., 1, 1), 'Braille', 'SIPrefixes') and
              IsInDefinition(substring(., 2), 'Braille', 'SIUnits')))
           )"
      then:
      - t: "U"
      - x: "BrailleChars(., 'Polish')"   # also deals with "dot after 'arc'"
      - t: "u"
    - else_if: "IsInDefinition(., 'Braille', 'CurrencySymbols')"
      then:
      - t: "WT"  
      - x: "BrailleChars(., 'Polish')"   # also deals with "dot after 'arc'"
      - t: "tW"  
      else:
      - test:
          # words have different rules from math. Guessing that strings of length 4 or more are words
          if: "self::m:mtext and string-length(.) > 3"
          then: [t: "T"] 
      - x: "BrailleChars(., 'Polish')"   # also deals with "dot after 'arc'"
      - test:
          if: "self::m:mtext and string-length(.) > 3"
          then: [t: "t"] 
      


-
  # 2.5b says that hex-like numbers don't reuse a numeric indicator after a letter -- here we try to catch that case.
  # Match if: 1) has a digit, 2) has A-F after first char, 3) only has digits and A-F
  # FIX: the rule doesn't restrict itself to hex digits, but in practice, that probably covers almost all cases
  name: hex-number
  tag: [mn, mtext]
  match:
  - "string-length(translate(., '0123456789', '')) <string-length(.) and "
  - "string-length(translate(substring(., 2), 'abcdefABCDEF', '')) <string-length(.) and "
  - "translate(., '0123456789abcdefABCDEF', '')=''"
  replace:
  - x: "BrailleChars(concat(substring(.,1,1), translate(substring(., 2), 'abcdefABCDEF',
            '\ue00a\ue00b\ue00c\ue00d\ue00e\ue00f\ue01a\ue01b\ue01c\ue01d\ue01e\ue01f')), 'Polish')"

-
  name: default
  tag: [mn, mo]
  match: "."
  replace:
  - x: "BrailleChars(., 'Polish')"

-
  name: default
  tag: mstyle
  match: "."
  replace:
  - test:
      if: "*"
      then: [x: "*"]
      # else do nothing -- no content

-
  name: modifiers
  tag: [mover, munder]
  # overbar can also be a script -- it seems the distinguishing feature is whether is it over a single char or something "bigger"
  match: "*[2][IsInDefinition(., 'Braille', 'Modifiers')] and not(*[1][self::m:mi and string-length(.)=1] and *[2][.='¬Ø'])"
  replace:
  - test:
      if: "self::m:mover"
      then: [t: "‚†®"]
      else: [t: "‚†∏"]
  - x: "*[2]"
  - x: "*[1]"
-
  name: double-dot
  tag: mover
  match: "*[2][self::m:mo and .='..']"  # 0x00AF
  replace:
  - x: "*[1]"
  - T: "‚†Ü‚†Ü"
  
-
  name: diacriticals
  tag: [mover, msup]
  # ions don't use the shortened form
  match: "not(@data-chem-formula) and *[2][self::m:mo and DefinitionValue(., 'Braille', 'Scripts')!='']"
  replace:
  - x: "*[1]"
  - test:
      if: "*[2][.='¬∞' or .='‚Ä≤' or .='‚Ä≥' or .='\"']"
      then: [t: "p"]
  - test:
      # superscripts for plus that have number bases (‚†ñ could be confused with fraction with denom 0) [FIX: others???]
      if: "self::m:msup and *[2][.='+'] and *[1][self::m:mn]"
      then: [t: "‚†ò"]
  - x: "DefinitionValue(*[2], 'Braille', 'Scripts')"
  
-
  name: time
  tag: msup
  # see p92 for examples
  match: "*[1][self::m:mn] and *[2][self::m:mn] and ancestor-or-self::*[contains(@intent, ':time')]"
  replace:
  - x: "*[1]"
  - t: "N‚†Ñ"
  - x: "*[2]"

-
  name: pseudo-scripts
  tag: msup
  match: "*[2][translate(., \"'‚Ä¥‚Åó*‚Üí‚ü∂‚Üê‚üµ+-¬¨.ÀôÀáÃä\", '')='']"
  replace:
  - x: "*[1]"
  - test:
      if: "@data-chem-formula and (*[2][.='+' or .='-'])"
      then: [x: "IfThenElse(*[2]='+', '‚†å‚†ñ', '‚†å‚†§')"]
      else:
      - x: "*[2]"

-
  name: prime-exception    # 4.3.1
  tag: msubsup
  match: "*[3][translate(., \"‚Ä≤‚Ä≥‚Ä¥‚Åó\",'')='']"
  replace:
  - x: "*[1]"
  - x: "*[3]"
  - t: "<‚†°"
  - x: "*[2]"
  - t: ">‚†±"

-
  name: log-with-base
  tag: msub
  match: "*[1][self::m:mi and .='log']"
  replace:
  - t: "‚†å"
  - test:
      if: "$Polish_BrailleLevel = 'Advanced' and *[2][self::m:mn and not(contains(., $DecimalSeparators))]"
      then: [x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
      else:
      # not part of the spec, but it is better to force a lower case indicator for the base of a log
      - test:
          if: "translate(*[2], 'abcdefghij', '') = ''"
          then: [t: "ùíç"]
      - x: "*[2]"
  - x: "*[1]"

-
  name: lim-with-script
  tag: [munder, msub]
  match: "*[1][self::m:mi][.='lim']"
  replace: 
  - x: "*[1]"
  - t: "<‚†°"
  - x: "*[2]"
  - t: ">W"

-
  # function inverse is not considered an exponent
  name: inverse-function
  tag: msup
  match: "*[1][IsInDefinition(., 'Braille', 'PolishFunctionName') or .='f' or .='g' or .='h'] and
          *[2][.='-1']"
  replace: 
  - x: "*[1]"
  - t: "<‚†å"     # I think these count as projectors even though they always go away
  - t: "‚†§n‚†Ç"
  - t: ">‚†±"

-
  # use drop numbers with no subscript indicator for chemical formulae
  name: chemical-subscript
  tag: msub
  match: "@data-chem-formula and
          *[2][self::m:mn and translate(., '0123456789', '') = '']"
  replace:
  - x: "*[1]"
  - x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"

-
  name: doubled-charge
  tag: msup
  match: "@data-chem-formula and *[2][self::m:mrow and (.='--' or .='++')]"
  replace:
  - x: "*[1]"
  - t: "‚†å"
  - test:
      if: "*[2][.='--']"
      then: [t: "‚†§‚†§"]
      else: [t: "‚†ñ‚†ñ"]

-
  name: doubled-charge
  tag: msubsup
  match: "@data-chem-formula and *[3][self::m:mrow and (.='--' or .='++')]"
  replace:
  - x: "*[1]"
  - test:
      - if: "*[2][self::m:mn and translate(*[2], '0123456789', '') = '']"
        then: [x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
        else:
        - t: "<‚†°"
        - x: "*[2]"
        - t: ">‚†±"
  - t: "‚†å"
  - test:
      if: "*[3][.='--']"
      then: [t: "‚†§‚†§"]
      else: [t: "‚†ñ‚†ñ"]

-
  # scripts
  # for some reason, the spec reverses the order of sub and sup for cap letters that are not chemistry
  name: cap-letter-scripts
  tag: msubsup
  match: "not(@data-chem-element) and BaseNode(*[1])[translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', '') = '']"
  # the examples all use superscripts, not exponents for cap letters these (for example p39 and p55)
  # also, for some reason, the cap letters use superscripts first
  replace:
  - x: "*[1]"
  - t: "<‚†å"
  - test:
      - if: "*[3][self::m:mn and translate(., '0123456789', '') = '']"
        then: [x: "BrailleChars(translate(*[3], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
      - else_if: "*[3][self::m:mrow and count(*)=2 and *[1]='-' and *[2][self::m:mn and translate(*[2], '0123456789', '') = '']]"
        then:
        - x: "*[3]/*[1]"
        - x: "BrailleChars(translate(*[3]/*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator
        else: [x: "*[3]"]
  - t: ">‚†±<‚†°"
  - test:
      - if: "*[2][self::m:mn and translate(., '0123456789', '') = '']"
        then: [x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
      - else_if: "*[2][self::m:mrow and count(*)=2 and *[1]='-' and *[2][self::m:mn and translate(*[2], '0123456789', '') = '']]"
        then:
        - x: "*[2]/*[1]"
        - x: "BrailleChars(translate(*[2]/*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator
        else: [x: "*[2]"]
  - t: ">‚†±"

-
  # scripts
  # simple numeric scripts are written as drop numbers
  name: default
  tag: [msub, msup, msubsup]
  match: "."
  # the examples all use superscripts, not exponents for cap letters these (for example p39 and p55)
  # also, for some reason, the cap letters use superscripts first
  variables:
  - IsCapLetter: "BaseNode(*[1])[translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', '') = '']"
  - BaseNeedsSuperscript: "self::m:msubsup and BaseNode(*[1])[self::m:mo or .='lim' or $IsCapLetter]"
  replace:
  - x: "*[1]"
  - test:
      - if: "self::m:msub or self::m:msubsup"
        then: [t: "<‚†°"]
      - else_if: "@data-chem-formula or $BaseNeedsSuperscript"    # must be a superscript
        then: [t: "<‚†å"]
        else: [t: "<‚†¨"]
  - test:
      - if: "*[2][self::m:mn and translate(., '0123456789', '') = '']"
        then: [x: "BrailleChars(translate(*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
      - else_if: "*[2][self::m:mrow and count(*)=2 and *[1]='-' and *[2][self::m:mn and translate(*[2], '0123456789', '') = '']]"
        then:
        - x: "*[2]/*[1]"
        - x: "BrailleChars(translate(*[2]/*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator
        else: [x: "*[2]"]
  - test:
      if: "self::m:msubsup"
      then:
      - test:
          if: "@data-chem-formula or $BaseNeedsSuperscript"    # must be a superscript
          then: [t: ">‚†±<‚†å"]
          else: [t: ">‚†±<‚†¨"]
      - test:
          - if: "*[3][self::m:mn and translate(., '0123456789', '') = '']"
            then: [x: "BrailleChars(translate(*[3], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
          - else_if: "*[3][self::m:mrow and count(*)=2 and *[1]='-' and *[2][self::m:mn and translate(*[2], '0123456789', '') = '']]"
            then:
            - x: "*[3]/*[1]"
            - x: "BrailleChars(translate(*[3]/*[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"   # drop numbers for the numerator
            else: [x: "*[3]"]
  - test:
      if: "*[1][.='lim' or .='‚à´' or .='‚à¨' or .='‚à≠' or .='|']"
      then: [t: ">W"]  # p56 and p57 say to terminate these with a space
      else: [t: ">‚†±"]


-
 
  name: oxidation-states   #p 85
  tag: mover
  match: "BaseNode(*[1])[@data-chem-element]"
  replace:
  - x: "*[1]"
  - t: "("
  - test:
      # should be 0 or a roman numeral
      if: "*[2][self::m:mn and .='0' and $Polish_BrailleLevel != 'Beginner']"
      then: [x: "BrailleChars('\ue000', 'Polish')"]   # drop zero
      else: [x: "*[2]"]   # indicates unknown oxidation state
  - t: ")"

-
  # FIX: not sure what to do -- this is based on p64 (last example) and only works for mover
  name: default
  tag: [munder, mover, munderover]
  match: "."
  replace:
  - test:
      if: "self::m:mover"
      then: [t: "W‚†∞"]
  - x: "*[1]"
  - t: "‚††"
  - x: "*[2]"
  - t: "‚†ÑW"

-
  # This is incredibly messy because it needs to handle all the special cases for scripts, and then repeat them for each pre/postscript
  # FIX: So far, I have only dealt with one prescript to handle atomic numbers
  # At least for chemistry, superscripts, then subscripts, with the base after prescripts
  # The number indicator is not needed for drop numbers
  name: default
  tag: mmultiscripts
  match: "."
  variables:
  # computing the number of postscripts is messy because of <mprescripts> being optionally present -- we use "mod" to get the count right
  - Prescripts: "m:mprescripts/following-sibling::*"
  - NumChildren: "count(*)"       # need to stash this since the count is wrong inside '*[...]' below
  - Postscripts: "*[position()>1 and position() < (last() + ($NumChildren mod 2) -count($Prescripts))]"
  replace:
  # - test: # special case superscript postscripts that preced the prescripts
  #     if: "$Postscripts and not($Postscripts[2][self::m:none]) and $Postscripts[2][translate(., \"‚Ä≤‚Ä≥‚Ä¥‚Åó'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
  #     then:
  #     - x: "$Postscripts[2]"
  #     - test:
  #         # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
  #         if: "translate($Postscripts[2], \"‚Ä≤‚Ä≥‚Ä¥‚Åó\", '')!='' and not($Postscripts[2][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
  #         then: [t: "‚†Ñ"]
  - test:
      if: "$Prescripts"
      then:
      - test:
          if: "not($Prescripts[2][self::m:none])"
          then:
          # - t: "‚†à‚†°"
          # - test:
          #     - if:
          #       - "$Prescripts[2][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
          #       - "count($Prescripts[2]/*) > 3 and string-length($Prescripts[2]/*[1])=1 and"    # at least four mo's, the first of which has a single char
          #       - "$Prescripts[2][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
          #       then:
          #       - x: "BrailleChars(count($Prescripts[2]/*), 'Polish')"
          #       - x: "$Prescripts[2]/*[1]"
          #       - test:
          #           # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
          #           if: "not($Prescripts[2][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
          #           then: [t: "‚†Ñ"]
          #     - else_if: "$Prescripts[2][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
          #       then:
          #       - x: "$Prescripts[2]"
          #       - test:
          #           # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
          #           if: "not($Prescripts[2][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
          #           then: [t: "‚†Ñ"]
          #     - else_if: "$Prescripts[2][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
          #       then:
          - t: "<‚†å"   # not an exponent
          - test:
              if: "$Polish_BrailleLevel = 'Advanced' and $Prescripts[2][self::m:mn][translate(., '0123456789', '') = '']"
              then: [x: "BrailleChars(translate($Prescripts[2], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
              else: [x: "$Prescripts[2]"]
          - t: ">‚†±"
      - test:
          if: "not($Prescripts[1][self::m:none])"
          then:
          # - t: "‚†°"
          # - test:
          #     - if:
          #       - "$Prescripts[1][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
          #       - "count($Prescripts[1]/*) > 3 and string-length($Prescripts[1]/*[1])=1 and"    # at least four mo's, the first of which has a single char
          #       - "$Prescripts[1][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
          #       then:
          #       - x: "BrailleChars(count($Prescripts[1]/*), 'Polish')"
          #       - x: "$Prescripts[1]/*[1]"
          #       - test:
          #           # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
          #           if: "not($Prescripts[1][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
          #           then: [t: "‚†Ñ"]
          #     - else_if: "$Prescripts[1][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
          #       then:
          #       - x: "$Prescripts[1]"
          #       - test:
          #           # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
          #           if: "not($Prescripts[1][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
          #           then: [t: "‚†Ñ"]
          #     - else_if: "$Prescripts[1][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
          #       then:
          - t: "<‚†°"
          - test:
              if: "$Polish_BrailleLevel = 'Advanced' and $Prescripts[1][self::m:mn][translate(., '0123456789', '') = '']"
              then: [x: "BrailleChars(translate($Prescripts[1], '0123456789', '\ue000\ue001\ue002\ue003\ue004\ue005\ue006\ue007\ue008\ue009'), 'Polish')"]
              else: [x: "$Prescripts[1]"]
          - t: ">‚†±"
          - test: # hack to force output of the terminator
              if: "$Polish_BrailleLevel = 'Advanced' and @data-chem-formula"
              then: [t: "+"]
      # - test:
      #     if: "count($Prescripts)>2"
      #     then:
      #     - test:
      #         if: "not($Prescripts[3][self::m:none])"
      #         then:
      #         - t: "‚††‚†å"
      #         - test:
      #             - if:
      #               - "$Prescripts[3][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
      #               - "count($Prescripts[3]/*) > 3 and string-length($Prescripts[3]/*[1])=1 and"    # at least four mo's, the first of which has a single char
      #               - "$Prescripts[3][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
      #               then:
      #               - x: "BrailleChars(count($Prescripts[3]/*), 'Polish')"
      #               - x: "$Prescripts[3]/*[1]"
      #               - test:
      #                   # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
      #                   if: "not($Prescripts[3][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
      #                   then: [t: "‚†Ñ"]
      #             - else_if: "$Prescripts[3][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
      #               then:
      #               - x: "$Prescripts[3]"
      #               - test:
      #                   # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
      #                   if: "not($Prescripts[3][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
      #                   then: [t: "‚†Ñ"]
      #             - else_if: "$Prescripts[3][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
      #               then:
      #               - t: "‚†¢"
      #               - x: "$Prescripts[3]"
      #               - t: "‚†î"
      #               else:
      #               - x: "$Prescripts[3]"
      #     - test:
      #         if: "not($Prescripts[4][self::m:none])"
      #         then:
      #         - t: "‚†à‚†°"
      #         - test:
      #             - if:
      #               - "$Prescripts[4][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
      #               - "count($Prescripts[4]/*) > 3 and string-length($Prescripts[4]/*[1])=1 and"    # at least four mo's, the first of which has a single char
      #               - "$Prescripts[4][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
      #               then:
      #               - x: "BrailleChars(count($Prescripts[4]/*), 'Polish')"
      #               - x: "$Prescripts[4]/*[1]"
      #               - test:
      #                   # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
      #                   if: "not($Prescripts[4][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
      #                   then: [t: "‚†Ñ"]
      #             - else_if: "$Prescripts[4][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
      #               then:
      #               - x: "$Prescripts[4]"
      #               - test:
      #                   # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
      #                   if: "not($Prescripts[4][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
      #                   then: [t: "‚†Ñ"]
      #             - else_if: "$Prescripts[4][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
      #               then:
      #               - t: "‚†¢"
      #               - x: "$Prescripts[4]"
      #               - t: "‚†î"
      #               else:
      #               - x: "$Prescripts[4]"
      #     - test:
      #         if: "count($Prescripts) > 4"   # give up and just dump them out so at least the content is there
      #         then: [x: "$Prescripts[position() > 4]"]

  - x: "*[1]"

  - test:
      if: "$Postscripts"
      then:
      - test:
          if: "not($Postscripts[1][self::m:none])"
          then:
          - t: "‚†å"
          - test:
              - if:
                - "$Postscripts[1][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
                - "count($Postscripts[1]/*) > 3 and string-length($Postscripts[1]/*[1])=1 and"    # at least four mo's, the first of which has a single char
                - "$Postscripts[1][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
                then:
                - x: "BrailleChars(count($Postscripts[1]/*), 'Polish')"
                - x: "$Postscripts[1]/*[1]"
                - test:
                    # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                    if: "not($Postscripts[1][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                    then: [t: "‚†Ñ"]
              - else_if: "$Postscripts[1][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
                then:
                - x: "$Postscripts[1]"
                - test:
                    # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                    if: "not($Postscripts[1][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                    then: [t: "‚†Ñ"]
              - else_if: "$Postscripts[1][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
                then:
                - t: "‚†¢"
                - x: "$Postscripts[1]"
                - t: "‚†î"
                else:
                - x: "$Postscripts[1]"
      - test:
          if: "not($Postscripts[2][self::m:none]) and $Postscripts[2][translate(., \"‚Ä≤‚Ä≥‚Ä¥‚Åó'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')!='']"
          then:
          - t: "‚†°"
          - test:
              - if:
                - "$Postscripts[2][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
                - "count($Postscripts[2]/*) > 3 and string-length($Postscripts[2]/*[1])=1 and"    # at least four mo's, the first of which has a single char
                - "$Postscripts[2][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
                then:
                - x: "BrailleChars(count($Postscripts[2]/*), 'Polish')"
                - x: "$Postscripts[2]/*[1]"
                - test:
                    # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                    if: "not($Postscripts[2][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                    then: [t: "‚†Ñ"]
              - else_if: "$Postscripts[2][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
                then:
                - t: "‚†¢"
                - x: "$Postscripts[2]"
                - t: "‚†î"
                else:
                - x: "$Postscripts[2]"
      - test:
          if: "count($Postscripts)>2"
          then:
          - test:
              if: "not($Postscripts[3][self::m:none])"
              then:
              - t: "‚†∞‚†å"
              - test:
                  - if:
                    - "$Postscripts[3][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
                    - "count($Postscripts[3]/*) > 3 and string-length($Postscripts[3]/*[1])=1 and"    # at least four mo's, the first of which has a single char
                    - "$Postscripts[3][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
                    then:
                    - x: "BrailleChars(count($Postscripts[3]/*), 'Polish')"
                    - x: "$Postscripts[3]/*[1]"
                    - test:
                        # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                        if: "not($Postscripts[3][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                        then: [t: "‚†Ñ"]
                  - else_if: "$Postscripts[3][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
                    then:
                    - x: "$Postscripts[3]"
                    - test:
                        # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                        if: "not($Postscripts[3][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                        then: [t: "‚†Ñ"]
                  - else_if: "$Postscripts[3][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
                    then:
                    - t: "‚†¢"
                    - x: "$Postscripts[3]"
                    - t: "‚†î"
                    else:
                    - x: "$Postscripts[3]"
          - test:
              if: "not($Postscripts[4][self::m:none])"
              then:
              - t: "‚†ò‚†°"
              - test:
                  - if:
                    - "$Postscripts[4][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
                    - "count($Postscripts[4]/*) > 3 and string-length($Postscripts[4]/*[1])=1 and"    # at least four mo's, the first of which has a single char
                    - "$Postscripts[4][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
                    then:
                    - x: "BrailleChars(count($Postscripts[4]/*), 'Polish')"
                    - x: "$Postscripts[4]/*[1]"
                    - test:
                        # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                        if: "not($Postscripts[4][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                        then: [t: "‚†Ñ"]
                  - else_if: "$Postscripts[4][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
                    then:
                    - x: "$Postscripts[4]"
                    - test:
                        # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                        if: "not($Postscripts[4][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                        then: [t: "‚†Ñ"]
                  - else_if: "$Postscripts[4][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
                    then:
                    - t: "‚†¢"
                    - x: "$Postscripts[4]"
                    - t: "‚†î"
                    else:
                    - x: "$Postscripts[4]"
          - test:
              if: "count($Postscripts)>4"
              then:
              - test:
                  if: "not($Postscripts[5][self::m:none])"
                  then:
                  - t: "‚†∞‚†å"
                  - test:
                      - if:
                        - "$Postscripts[5][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
                        - "count($Postscripts[5]/*) > 3 and string-length($Postscripts[5]/*[1])=1 and"    # at least four mo's, the first of which has a single char
                        - "$Postscripts[5][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
                        then:
                        - x: "BrailleChars(count($Postscripts[5]/*), 'Polish')"
                        - x: "$Postscripts[5]/*[1]"
                        - test:
                            # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                            if: "not($Postscripts[5][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                            then: [t: "‚†Ñ"]
                      - else_if: "$Postscripts[5][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
                        then:
                        - x: "$Postscripts[5]"
                        - test:
                            # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                            if: "not($Postscripts[5][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                            then: [t: "‚†Ñ"]
                      - else_if: "$Postscripts[5][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
                        then:
                        - t: "‚†¢"
                        - x: "$Postscripts[5]"
                        - t: "‚†î"
                        else:
                        - x: "$Postscripts[5]"
              - test:
                  if: "not($Postscripts[6][self::m:none])"
                  then:
                  - t: "‚†ò‚†°"
                  - test:
                      - if:
                        - "$Postscripts[6][self::m:mrow[not(./*[name() != 'mo'])]] and" # script consists of all mo's
                        - "count($Postscripts[6]/*) > 3 and string-length($Postscripts[6]/*[1])=1 and"    # at least four mo's, the first of which has a single char
                        - "$Postscripts[6][ not(./*[text()] != *[1][text()]) ]" # they are all have the same text (we know it is an mrow)
                        then:
                        - x: "BrailleChars(count($Postscripts[6]/*), 'Polish')"
                        - x: "$Postscripts[6]/*[1]"
                        - test:
                            # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                            if: "not($Postscripts[6][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                            then: [t: "‚†Ñ"]
                      - else_if: "$Postscripts[6][translate(., \"'*`+-¬™¬∞¬≤¬≥¬¥¬π¬∫‚Äò‚Äô‚Äú‚Äù‚Äü‚Äµ‚Ä∂‚Ä∑\",'')='']"
                        then:
                        - x: "$Postscripts[6]"
                        - test:
                            # degree doesn't use dot-3 for chemistry, temp, angles -- can't know that so we make a wild guess here
                            if: "not($Postscripts[6][.='¬∞'] and *[1][self::m:mn or @data-chem-element])" 
                            then: [t: "‚†Ñ"]
                      - else_if: "$Postscripts[6][((self::m:mrow and not(IsBracketed(., '', '')) and not(*[1][self::m:mo][.='-'])) or IsNode(., 'modified')) or self::m:mfrac]"
                        then:
                        - t: "‚†¢"
                        - x: "$Postscripts[6]"
                        - t: "‚†î"
                        else:
                        - x: "$Postscripts[6]"
              - test:
                  if: "count($Postscripts) > 6"   # give up and just dump them out so at least the content is there
                  then: [x: "$Postscripts[position() > 6]"]
                  

-
# Note: @notation can contain more than one value
# I don't think CMU has a good way to represent all notations, especially when in combination
# FIX: this needs to be flushed out
  name: default
  tag: menclose
  match: "."
  replace:
  - test:
      if: "contains(@notation,'box')"
      then_test: 
          if: "*[1][self::m:mtext and .='\u00A0']"                  # box and roundedbox
          then: [t: "‚†∞‚†§‚†Ü"]                            # omission
          else: [t: "1‚†´‚†º‚†ô"]                           # square (no rectangle in UEB)
      else:
      - with:
          variables:
          - IsCancellation: "contains(@notation,'updiagonalstrike') or contains(@notation,'downdiagonalstrike') or 
                             contains(@notation,'verticalstrike') or contains(@notation,'horizontalstrike')"
          replace:
          - test:
              if: "contains(@notation,'top')"
              then: [t: "‚†à‚†â"]                  # overline
          - test:
              if: "contains(@notation,'bottom')"
              then: [t: "‚††‚†§"]                  # underline
          - test:
              if: "$IsCancellation"
              then: [t: "‚†ª"]                   # cancellation
          - test:
              if: "*[1][(IsNode(., 'leaf') and (string-length(.) = 1 or IsInDefinition(., 'Braille', 'PolishFunctionName'))) or IsBracketed(., '', '')]"
              then: [x: "*[1]"]
              else:
              - t: "‚†¢"
              - x: "*[1]"
              - t: "‚†î"

  #  - test:
  #     if: "contains(concat(' ', normalize-space(@notation), ' '), ' left ')"                  #avoid 'leftarrow'
  #     then: [t: "‚†∏"]
  #  - test:
  #     if: "contains(@notation,'circle')"
  #     then:
  #     # - test:
  #     #    if: "$AddSpaces"
  #     #    then: [t: " "]
  #     - t: "1‚†´‚†ø"                                  # circle (no oval in UEB)
# ??? What should happen with arrow?
#  If there is a box/circle with arrows only and an empty child,
#     then it acts like the arrow is the child
#  If there are only arrows for 'notation', then maybe rule 112 applies (superposition),
#     but the examples aren't similar. In that case, the arrow acts like 'box' and the child is the content... maybe  
# 
#  - test:
#      if: "contains(@notation,'leftarrow')"
#      then: [t: left arrow, pause: short]
#  - test:
#      if: "contains(concat(' ', normalize-space(@notation), ' '), ' rightarrow ')"
#      then: [t: right arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northeastarrow')"
#      then: [t: northeast arrow, pause: short]
#  - test:
#      if: "contains(concat(' ', normalize-space(@notation), ' '), ' southeastarrow ')"
#      then: [t: southeast arrow, pause: short]
#  - test:
#      if: "contains(concat(' ', normalize-space(@notation), ' '), ' southwestarrow ')"
#      then: [t: southwest arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northwestarrow')"
#      then: [t: northwest arrow, pause: short]
#  - test:
#      if: "contains(@notation,'updownarrow')"
#      then: [t: double ended vertical arrow, pause: short]
#  - test:
#      if: "contains(@notation,'leftrightarrow')"
#      then: [t: double ended horizontal arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northeastsouthwestarrow')"
#      then: [t: double ended up diagonal arrow, pause: short]
#  - test:
#      if: "contains(@notation,'northwestsoutheastarrow')"
#      then: [t: double ended down diagonal arrow, pause: short]
#  - test:
#      if: ".[contains(@notation,'actuarial')]"
#      then: [t: actuarial symbol, pause: short]
#  - test:
#      if: ".[contains(@notation,'madrub')]"
#      then: [t: arabic factorial symbol, pause: short]
#  - test:
#      if: ".[contains(@notation,'longdiv') or not(@notation) or normalize-space(@notation) ='']"      # default
#      then: [t: long division symbol, pause: short]
#  - test:
#      if: ".[contains(@notation,'radical')]"
#      then: [t: square root, pause: short]

  #  - test:
  #     # omit grouping indicators in the following cases
  #     if:   # FIX: need to add arbitrary shapes here (also for mroot) also multi-char leaf translations except mi
  #           # next test is to make sure there is just one symbol
  #           # FIX: the double dot test is likely wrong, but I can't find what other exceptions there are 
  #     - "*[1][self::m:mn or"
  #     - "     ((self::m:mi or self::m:mo) and string-length(text())=1 and text()!='¬®') or"
  #     - "     self::m:mfrac or self::m:msqrt or self::m:mroot or"
  #     - "     IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '{', '}') or"
  #     - "     IsInDefinition(., 'Braille', 'Arrows')"
  #     - "    ]"
  #     then: [x: "*[1]"]
  #     else:
  #     - t: "1‚†£"
  #     - x: "*[1]"
  #     - t: "1‚†ú"

   # - test:
   #    if: "contains(@notation,'phasorangle')"  #FIX: what should this be???
   #    then: [t: "‚†´‚†™‚†∏‚†´"]
  #  - test:
  #     if: "contains(@notation,'arrow')"    # all the arrows
  #     then:
  #     - test:
  #        - if: "contains(@notation,'rightarrow')" 
  #          then: [t: "1‚†≥‚†ï"]                                                           
  #        - else_if: "contains(@notation,'leftarrow')" 
  #          then: [t: "1‚†≥‚†™"]                                                           
  #        - else_if: "contains(@notation,'uparrow')" 
  #          then: [t: "1‚†≥‚†¨ "]                                                           
  #        - else_if: "contains(@notation,'downarrow')" 
  #          then: [t: "1‚†≥‚†©"]                                                           
  #        - else_if: "contains(@notation,'northeastarrow')" 
  #          then: [t: "1‚†≥‚†é"]                                                           
  #        - else_if: "contains(@notation,'southeastarrow')" 
  #          then: [t: "1‚†≥‚†£"]                                                           
  #        - else_if: "contains(@notation,'northwestarrow')" 
  #          then: [t: "1‚†≥‚†±"]                                                           
  #        - else_if: "contains(@notation,'southwestarrow')" 
  #          then: [t: "1‚†≥‚†ú"]                                                           
  #        - else_if: "contains(@notation,'leftrightarrow')" 
  #          then: [t: "1‚†≥‚†∫‚†ó‚†ï"]                                                           
  #        - else_if: "contains(@notation,'updownarrow')" 
  #          then: [t: "1‚†≥‚†∫‚†ó‚†¨"]                                                           
  #        - else_if: "contains(@notation,'northeastsouthwestarrow')" 
  #          then: [t: "1‚†≥‚†∫‚†ó‚†é"]                                                           
  #        - else_if: "contains(@notation,'northwestsoutheastarrow')" 
  #          then: [t: "1‚†≥‚†∫‚†ó‚†£"]                                                           
  #  - test:
  #     if:
  #     - "not($AddSpaces) and contains(@notation,'box') or contains(@notation,'circle') or"
  #     - "contains(@notation,'arrow') or contains(@notation,'phasorangle')" 
  #     then:
  #     - t: "‚†ª"                   # terminate shape
  #     # - test:
  #     #    if: "$AddSpaces"
  #     #    then: [t: " "]
  #  - test:
  #     if: "contains(concat(' ', normalize-space(@notation), ' '), ' right ')"                  #avoid 'rightarrow'
  #     then: [t: "‚†∏"]



-
   name: default
   tag: ms
   match: "."
   replace:
      - test:
         if: "string(@lquote)!=''"
         then: [x: "@lquote"]
         else: [t: "‚†Ñ‚†Ñ"]
      - x: "BrailleChars(., 'Polish')"
      - test:
         if: "string(@rquote)!=''"
         then: [x: "@rquote"]
         else: [t: "‚†Ñ‚†Ñ"]

-
   name: default
   tag: semantics
   match: "."
   replace: 
      - x: "*[1]"             #/ FIX: should prioritize @encoding="MathML-Presentation" and @encoding="application/mathml-presentation+xml"

-
   name: default-children
   tag: "*"
   match: "*"    # make sure there are children
   replace: 
   - t: "unknown math m l element"
   - x: "name(.)"
   - x: "*"

-
   # at this point, we know there are no children -- might be no text
   name: default-no-children
   tag: "*"
   match: "text()"
   replace: 
   - t: unknown math m l element
   - x: "name(.)"
   - x: "text()"

-
   name: default-no-text
   tag: "*"
   match: "."
   replace: 
    - t: "empty unknown math m l element"
    - x: "name(.)"
